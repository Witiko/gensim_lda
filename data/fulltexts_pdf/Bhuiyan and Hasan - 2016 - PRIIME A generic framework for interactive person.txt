arXiv:1607.05749v1 [cs.LG] 19 Jul 2016
PRIIME: A Generic Framework for Interactive Personalized
Interesting Pattern Discovery
Mansurul
A Bhuiyan
Dept. of Computer Science, Indiana
University—Purdue University
Indianapolis, USA
mbhuiyan@iupui.edu
Mohammad Al Hasan
Dept. of Computer Science, Indiana
University—Purdue University
Indianapolis, USA
alhasan@cs.iupui.edu
ABSTRACT
The traditional frequent pattern mining algorithms generate
an exponentially large number of
patterns of
which a sub-
stantial
proportion are not much significant for many data
analysis endeavors.
Discovery of a small number of personal-
ized interesting patterns from the large output set according
to a particular user’s interest is an important as well as chal-
lenging task.
Existing works on pattern summarization do
not solve this problem from the personalization viewpoint.
In this work,
we propose an interactive pattern discovery
framework named PRIIME which identifies a set of interest-
ing patterns for a specific user without requiring any prior
input on the interestingness measure of
patterns from the
user.
The proposed framework is generic to support discov-
ery of the interesting set, sequence and graph type patterns.
We develop a softmax classification based iterative learning
algorithm that uses a limited number of
interactive feed-
back from the user to learn her interestingness profile,
and
use this profile for pattern recommendation.
To handle se-
quence and graph type patterns PRIIME adopts a neural
net (NN) based unsupervised feature construction approach.
We also develop a strategy that combines exploration and
exploitation to select patterns for feedback.
We show ex-
perimental
results on several
real-life datasets to validate
the performance of the proposed method.
We also compare
with the existing methods of
interactive pattern discovery
to show that our method is substantially superior in perfor-
mance.
To portray the applicability of
the framework,
we
present a case study from the real-estate domain.
1.
INTRODUCTION
Frequent pattern (itemsets,
sequences,
or graphs) min-
ing [35] has been a core research task in data mining domain
for over two decades,
yet its deployment in real-life data
analysis has been moderate due to the following two chal-
lenges:
(1) the pattern space is combinatorial, so the number
of patterns that a mining task produces is generally too large
to process by an end-user; (2) for various data analysis tasks,
ACM ISBN 978-1-4503-2138-9.
DOI:
10.1145/1235
frequency threshold is not a sufficient filter criterion for se-
lecting patterns.
To overcome (1),
many works have been
proposed for pattern summarization and compression [19,
32], and to overcome (2), several alternative interestingness
metrics, such as, Jaccard index, odds ratio, and lift [35] have
been proposed which can be used together with frequency.
Nevertheless,
interesting pattern discovery still
remains an
unsolved problem due to the subjectivity in the definition
of
interestingness.
In many cases,
for a specific user,
off-
the-shelf interestingness metrics does not represent her true
interestingness over patterns.
Pattern summarization does
not help either,
as such an approach solves interesting pat-
tern discovery from a global
perspective which is far from
personalization what is needed to meet the pattern discovery
demand of a specific user.
There exist a few works which target personalized pat-
tern discovery by using users feedback [33, 6, 4].
The overall
methodologies of these works are to build an interactive pat-
tern discovery system,
that works as the following—a user
provides ratings on a small
collection of patterns,
then the
system uses these rating to train a personalization model,
which is later used to isolates user’s preferred patterns from
the remaining patterns.
Major design choices of
an inter-
active pattern discovery system are:
(1)
genericness,
i.e.
the kinds of patterns that the system supports; (2) pattern
selection process for feedback—whether it is active [26]
or
non-active; (3) learning model that the system uses; and (4)
feature representation of
patterns for facilitating learning.
Existing solutions for interactive pattern discovery are poor
on multiple among the above design choices.
We elaborate
more on this in the following paragraphs.
The majority of the existing platforms for interactive pat-
tern discovery only support itemset patterns because they
do not have an effective metric embedding for more com-
plex patterns,
say,
sequences,
or graphs.
Metric embed-
ding of
patterns is needed for facilitating the training of
a model
which discriminates between interesting and not-
so-interesting patterns.
For itemset patterns, existing works
leverage bag of
items for instrumenting a metric represen-
tation.
However,
no such natural
instrumentation is avail-
able for complex patterns,
such as a sequence,
or a graph.
Sometimes,
n-grams are used for metric embedding of
se-
quences [2],
and topological
measures,
such as centralities,
eccentricity,
egonet degree,
egonet size,
and diameter are
used for feature representation of
graphs [17].
While the
above feature representation may work well
for the task of
traditional sequence or graph classification, they do not work
well for frequent patterns which are numerous and small
in
size.
So, a generic yet principled approach is needed for met-
ric embedding of
complex patterns,
such as sequences and
graphs.
For any interactive learning platform, designing a method
for selecting a small
set of patterns for which a user’s feed-
back is sought is critical.
Given that the number of frequent
patterns is typically enormous,
the performance of interac-
tive learning depends critically on the module that selects
the patterns for collecting user’s feedback.
Most of the ex-
isting interactive pattern discovery works [33, 4] heavily en-
tangle model
learning with the feedback set selection;
i.e.
the influence of a model which is trained on the prior sets of
feedback is high when they select patterns for a user’s feed-
back.
So, the initial sets of feedback play a significant role to
the model’s configuration hence, the model may risks suffer-
ing from the positive reinforcement phenomenon.
In other
words, high influence of the current model to select patterns
for obtaining the user’s feedback in the next iteration is simi-
lar to exploitation in active learning [7].
It sometimes makes
the predictive model
represents some areas of
the pattern
space, making it sub-optimal over the entire pattern space.
In this work,
we propose a generic framework for inter-
active personalized interesting pattern discovery (IPIPD)
called PRIIME
1
by incorporating a user in the discovery
pipeline.
The proposed method uses preference rating of a
small set of frequent patterns from the user to learn her in-
terestingness criteria and recommend a set of patterns which
incline the most towards her choice.
To address the chal-
lenges discussed above, we develop a neural net based unsu-
pervised feature vector representation scheme for sequence
and graph patterns.
We propose a pattern selection ap-
proach for feedback to combat the positive reinforcement
phenomenon.
We also assume that feedback is given using
positive real discrete values, where a higher value stands for
more empathy towards the given pattern.
For example,
a
user can have a three-class rating system, where 1, 2 and 3
means dislike, not sure and likes the pattern.
In recent years, unsupervised feature learning using tradi-
tional and deep neural networks has become popular.
These
methods
help an analyst
discover
features
automatically,
thus obviating feature engineering using domain knowledge.
Researchers achieve excellent performance with these unsu-
pervised learning techniques for extraction of features from
text
[20],
speech [29]
and images
[30].
Recently in [23],
authors have shown the potential
of building unsupervised
feature representation of the vertices of an input graph for
vertex classification [23].
PRIIME’s metric representation
method for graphs and sequences is motivated from these
works.
Specifically, for a set of sequence or graph patterns,
PRIIME maps each pattern into a sentence and pattern el-
ements (items in a sequence or edges in a graph) as words.
Afterwards, it leverages a language model similar to [16] for
finding d-dimensional
feature vector representation of
the
patterns.
We experimentally show that such technique per-
forms better than the existing ad-hoc metric embedding.
PRIIME also provides a robust pattern selection strategy
for rating solicitation.
Unlike earlier interactive pattern dis-
covery works [33,
4],
for the case of PRIIME,
the coupling
between the existing state of
the learning model
and the
training set selection is significantly reduced which yields a
1
PRIIME is
an anagram of
the bold letters
in geneRic
fraMwork for Interactive pErsonalized Interesting Pattern
discovery
much-improved learning model.
In fact,
PRIIME’s strat-
egy is a combination of exploration and exploitation which
enables it to reduce the bias that existing state of the learn-
ing model imposes on pattern selection.
Exploitation aspect
of
the proposed strategy prefers patterns (for feedback so-
licitation)
that are likely to influence the learning model
the most,
i.e.
have the largest impact on model’s param-
eters.
On the other hand,
the exploration aspect ensures
that a broader span of
the pattern space is covered.
PRI-
IME maximizes expected gradient length (EGL) [27]
(an
active learning strategy) for exploitation and it chooses a
diverse set of
patterns using k-center [1]
search for explo-
ration.
We empirically show that a combination of
above
two triggers better learning performance than the existing
interactive pattern discovery frameworks.
We claim the following contributions:
• We propose a generic interactive personalized interesting
pattern discovery framework called PRIIME that is based
on iterative learning of a user’s interestingness function us-
ing the supervised classification model.
The system does
not require any prior knowledge of the user’s interestingness
criteria and needs a limited degree of user engagement.
• We develop an efficient unsupervised feature construction
scheme for sequence and graph patterns and propose a pat-
tern selection strategy combining exploitation and exploita-
tion for feedback collection.
• We perform exhaustive empirical
validations of
the pro-
posed framework using real-world set,
sequence,
and graph
datasets.
We show that the proposed feature construction
and pattern selection performs better than the existing ones.
To show the applicability of the interactive solution of per-
sonalized interesting pattern discovery,
we present a case
study from the real-estate domain using a real-life housing
data.
The reminder of this paper is organized as follows.
In Sec-
tion 2,
we discuss in detail
of the proposed framework.
In
Section 3, we talk about the learning algorithm of the frame-
work including pattern representation (Subsection 3.1), clas-
sification model (Subsection 3.2) and feedback mechanism (Sub-
section 3.3).
In Section 4, we present an extensive empirical
evaluation including the performance of
the learning algo-
rithm (Subsection 4.4),
neural
net based unsupervised fea-
ture construction (Subsection 4.6) and comparisons with the
existing methods (Subsection 4.5).
In Section 5, we present
a case study to establish the real life application of the pro-
posed framework in a real-estate domain problem.
We con-
clude the paper with related works (Section 6) and a con-
clusion (Section 7).
2.
PROBLEM DEFINITION AND SYSTEM
ARCHITECTURE
Consider,
a transactional
dataset D;
each transaction in
D is a combinatorial object, such as an itemset, a sequence,
or a graph.
Depending on the kind of objects in D, it can be
an itemset dataset,
a sequence dataset or a graph dataset.
A user u is interested in mining interesting patterns from
D,
where the patterns (denoted by set O) are sub-objects,
say subsets, subsequences, or subgraphs, over the objects in
D.
Traditional
approaches consider frequency as the inter-
estingness metric and design frequent pattern mining algo-
rithms which return patterns that exceed minimum support
thresholds over the transactions in D.
However,
due to the
tid
sid
gid
1
2
N
1
2
N
1
2
N
transaction
transaction
transaction
a b c d
c d f
a d e f
aabb
acggt
bbccdd
b
b
b
b
b
b
b
b
b
b
b
Frequent
Pattern
Miner
itemset
sequence
graph
Learner
Batch of
Patterns
Feature
Generator
Feedback
Collector
Model
Learning
Discovery
b
b
b
Interesting Patterns
Train
Send
Collect
b
b
b
b
b
b
b
b
b
b
b
b
Model
Figure 1:
Generic Interactive Personalized Interesting Pat-
tern Discovery Framework
fact that the frequent pattern space is combinatorial,
ex-
isting frequent pattern mining algorithms generally return
a large number of
patterns causing information overload.
Interactive pattern mining is a framework for negotiating
information overload so that a succinct set of
interesting
patterns (a small subset of frequent patterns, O) can be de-
livered to u, which are personalized by utilizing u’s feedback
on a small
number of patterns.
We call this framework IP-
IPD,
which stands for interactive personalized interesting
pattern discovery.
PRIIME,
our proposed method in this
paper follows this framework.
We assume,
u possesses an interestingness function (say,
f ) over the frequent patterns, O).
f maps each pattern in O
to a positive integer number indicating interestingness crite-
ria of the user u i.e., f : O →
Z
+
.
PRIIME learns f through
an active learning process over multiple learning iterations.
During an iteration (say i), the system returns a set of pat-
terns {p
t
}
1≤t≤l
to u,
which is selected from a partition of
O (which constitutes the i’th batch of pattern-set); u sends
feedback {y
t
= f(p
t
)}
1≤t≤l
using an interactive console; y
t
’s
are positive integer numbers reflecting the user’s empathy
towards the selected patterns;
using the feedback the sys-
tem updates its current model
of the user’s interestingness
function, f .
An alternative to our batch learning framework
can be to mine all
the frequent patterns and select a rela-
tively smaller subset of patterns for getting a user’s feedback
and use these for learning in one iteration.
This approach is
not scalable as the number of frequent patterns in O is typi-
cally very large even for a moderate-size dataset.
Besides, if
the learning entity receives the frequent patterns as a data
stream the one-iteration learning becomes infeasible,
but a
batch learning framework still works.
The IPIPD framework of PRIIME is partitioned into two
main blocks:
Learning and Discovery (Figure 1).
Learning
learns a model for a user; it contains following five modules:
Frequent Pattern Miner (FPM),
Learner,
Feature Genera-
tor (FG) and Feedback-Collector (FC),
and Model.
The
FPM works as a bridge between the Learner and the data.
FPM module can be any off-the-shelf
pattern mining al-
gorithm that mines frequent patterns given a normalized
minimum support threshold.
Any of
the existing off the
shelf pattern mining algorithms ranging from sequential [3]
to randomized [15], can be used.
The Learner learns u’s in-
terestingness function (f ) over the pattern-set O in multiple
stages while utilizing user’s feedback on a small
number of
patterns selected from a partition of O in each stage.
The
Feature Generator (FG) module is responsible for generat-
ing efficient and appropriate feature vector representation
of
the incoming patterns for the Feedback Controller and
the Model to use.
FG uses the bag of words method for set
patterns and NN-based unsupervised language model for se-
quence and graph patterns.
The Feedback-Collector (FC)’s
responsibility is to identify the patterns using a exploitation-
exploitation based strategy (explained in Section 3.3),
that
are sent to the user for feedback.
Note that,
patterns are
sent to the user for feedback in its original form,
not in the
feature vector representation.
Discovery delivers personal-
ized interesting patterns to the user using the learned model.
We like to highlight one relevant fact about the learning
task of the proposed framework.
In the learning phase, the
interaction between the FPM and the Learner is one-way,
from the FPM to the Learner,
and the Learner has no in-
fluence over FPM’s mining process.
This setup works well
for large datasets for which the mining task may take longer
time,
yet the learning task can start as soon as the first
batch of patterns is available.
Moreover,
if a user wants to
end the learning session before FPM finishes, the learner can
still
recommend patterns to the user based on the current
learning model.
PRIIME
Learning(D):
comment:
D is the transaction dataset,
1.
M
f eat
= Train feature generation model(D)
2.
Initialize model parameters w
3.
while 1:
4.
B = Incoming batch of patterns from F P M
5.
P
f eat
= Get feature representation(B,M
f eat
)
6.
P = Collect feedback(P
f eat
)
7.
w
′
= Train learning model(P,w)
8.
if ||w
′
-w|| < threshold:
9.
break
10.
w = w
′
11.
return w
Figure 2:
Pseudo code of Iterative Learning of PRIIME
3.
LEARNING METHOD
In PRIIME ,
the learning of
interestingness function f
and pattern mining by FPM proceeds
in parallel
over
a
few iterations.
In the i’th iteration,
PM generates a par-
tition (B
i
) of
frequent pattern set O,
and Learner selects
l
patterns {p
t
}
1≤t≤l
from B
i
and send them to u for rat-
ing.
Meanwhile,
FG obtains {x
t
}
1≤t≤l
,
the feature repre-
sentation of the patterns {p
t
}
1≤t≤l
.
Partitioning of frequent
pattern enables model learning to proceed even if all the fre-
quent patterns are not available, which is better than earlier
works [33] where model learning is performed after the entire
O is available.
Learner collects u’s rating {y
t
= f(p
t
)}
1≤t≤l
using an interactive console.
Then the Learner updates its
current model f using hx
t
, y
t
i.
In Figure 2,
we present the pseudo code of
PRIIME’s
learning phase.
PRIIME starts by training the unsuper-
vised feature generation model M
f eat
using the transaction
data D and initializes the learning model
w.
Afterward in
each iteration,
it uses M
f eat
to infer the feature represen-
tation of
each pattern in the incoming batch B.
Then the
algorithm selects patterns for feedback and sends them to
the user.
Once it receives the feedback, it updates the cur-
rent learning model.
The algorithm continues until the im-
provement of the learning model
falls below a user-defined
threshold.
In the following,
we discuss each of the tasks.
3.1
Pattern Representation
Say D = (T
1
, T
2
, · · · , T
N
) is a transaction dataset.
I is the
set of all single length frequent patterns.
I is a set of item, a
set of events, or a set of edges depending on whether D is an
itemset,
a sequence or a graph dataset,
respectively.
For a
given support threshold, O is the set of all frequent patterns.
For using a machine learning method for finding interesting
patterns, PRIIME first finds a feature vector representation
of these patterns.
3.1.1
Set Patterns
For a set data, each transaction T
i
is a collection of non-
repetitive items.
Considering the dataset D as a text corpus
and each transaction in the corpus as a document,
the set
I can be represented as the dictionary of
frequent words
i.e.
items.
Following the bag of words model,
we represent
each pattern p ∈ O as a binary vector V of
size |I|,
con-
structed as below:
V (i) =

1,
if item i ∈ p
0,
otherwise
Such a representation maps each pattern to a data point
x ∈ {0, 1}
|I|
space.
For example, consider a dataset in which
A, B, C, and E are frequent items.
Thus I = {A, B, C, E};
A frequent pattern AB will
be represented by the vector
(1, 1, 0, 0); a pattern ACE will be represented by the vector
(1, 0, 1, 1) and so on.
Sid
Sequence
1
aabbcc
2
bcbd
3
abcdab
.
.
.
.
.
.
N
abdabd
Text Document
Step 1
NN-based
Language
Model
Step 2





1
2
· · ·
d
1
x
11
x
12
· · ·
x
1d
2
x
21
x
22
· · ·
y
2d
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
N
z
N1
x
N2
· · ·
x
Nd





Feature Generation Model
(
M
f eat
)
Step 3
Figure 3:
Unsupervised Feature Construction of
Sequence
Patterns
3.1.2
Sequence Pattern
In sequence dataset D,
each transaction T
i
is an ordered
list of events.
For example,
ACCGA is sequence and A,
C
and G are events.
Similar to set, One can view the dataset
D as a text corpus and sequence of events in a transaction
as a sentence in a language, where the events are the words.
Given a set of sentences, our objective is to find a language
model
in which a sequence has a metric embedding in an
appropriately chosen vector space.
To obtain the language
model,
we apply Paragraph Vector [16].
It finds the d-
dimensional
(d is user defined) feature representation of all
sequences in D.
In Figure 3,
we illustrate how we compute feature repre-
sentation of the sequences in D.
As we can see, we treat se-
quences as sentences in a text corpus (step 1 in Figure 3).
In
the 2nd step, we pass the corpus in the language model (shown
as a black box in Figure 3).
As an output (step 3 in Fig-
ure 3),
language model
produces feature representation of
a given length (d−dimension) for all
transactions,
i.e.
se-
quences (1, 2, · · · N ).
Note that,
training of
such language
model is computationally expensive and perform training in
each iteration of PRIIME with the incoming batch of pat-
terns is inefficient.
As an alternative,
PRIIME trains the
model say, M
f eat
using the dataset D as training data (Line
1 in Figure 2).
Afterward in each iteration,
it populates
d-dimensional
feature vector of incoming patterns by using
M
f eat
.
1
a
2
b
3
c
4
c
5
b
6
a
Step 1
1:a:2:b:1 2:b:4:c:1 4:c:6:a:1
6:a:5:b:1 5:b:3:c:1 3:c:1:a:1
2:b:4:c:1 4:c:6:a:1 6:a:5:b:1
5:b:3:c:1 3:c:1:a:1 1:a:2:b:1
· · ·
· · ·
· · ·
· · ·
Text Document
Step 2
NN-based
Language
Model
Step 3





1
2
· · ·
d
1
x
11
x
12
· · ·
x
1d
2
x
21
x
22
· · ·
x
2d
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
M
x
M1
x
M2
· · ·
x
Md





Feature Generation Model
(
M
f eat
)
Step 4
Figure 4:
Unsupervised Feature Construction of Graph Pat-
terns
3.1.3
Graph Pattern
In graph dataset D, each transaction T
i
is a labeled, undi-
rected and connected graph.
In order to use neural network
based unsupervised language model,
we have to map the
dataset D to a text corpus and the graphs in D to sentences,
on which we apply Paragraph Vector [16].
For converting a
graph into sentence(s) we break the graph into a collection of
simple paths, such that edge ordering is maintained in each
path.
Each path can then be viewed as a sentence and the
edges in the path as words.
To construct these paths from
a graph T
i
,
for each node u in T
i
,
we perform a dfs-walk
originated from u that traverse all the edges in T
i
.
The mo-
tivation of using dfs-walk is that it preserves topological in-
formation of a graph around the originated vertex; multiple
dfs-walks originated from different vertices capture topolog-
ical information of the entire graph.
Besides, it provides an
ordering of edges in the paths which serves as sentences.
The
number of paths that we generate from each graph is exactly
equal
to the number of
vertices in the graph because each
dfs-path is originated from a distinct vertex in the graph.
Note that, for a set or a sequence dataset, we maintain a
one-to-one mapping between the transactions and the sen-
tences, but for graph, it is a one-to-many mapping.
The pri-
mary reason for this is that a complex object like graphs can-
not be represented by only one sequence of
vertices.
More
importantly,
the number of
transactions for graph data is
usually small
(Table 1) compared to a dataset of
sets and
sequences.
So populating one sentence per graph is
not
an optimal
choice.
In many of
the existing works on ma-
chine learning, specifically in deep learning, artificial random
noises are inserted to create distorted samples [28, 9] which
greatly increases the training set size.
In [28],
authors pro-
posed a technique called “elastic distortion” to increase the
number of
image training data by applying simple distor-
tions such as translations, rotations, and skewing.
However
in the existing works,
no such mechanism is available for
training data inflation for a graph data.
The one-to-many
mapping that we use is such a mechanism which enables us
to create many samples for a graph instance, thus increasing
the learning ability of the model for graph patterns.
In Figure 4, we illustrate the entire process.
In Step 1, we
have a graph (transaction) with 6 nodes and 6 edges, where
each of
the nodes has a label.
We assume all
the edges
share the same label 1 (not shown in the figure).
Step 2 ob-
tains six dfs-walk edge sequences,
on which two are shown
in the figure—one dfs-walk originated from vertex 1 (red
ink) and the other originated from vertex 2 (blue ink and
dashed).
Note that, it is possible to have dfs-walk with dif-
ferent ordering from a vertex but in this work,
we allow
one walk per vertex.
Once we have such representation of
the entire data D,
we feed the text corpus to the language
model
(Step 3) and finally for a given feature length d,
it
trains the model
(M
f eat
) and produces feature vectors of
all
M dfs-walks in the text corpus.
During the classifica-
tion stage for a pattern graph,
we create only one dfs-walk
from a randomly selected vertex and generate feature vector
representation by using M
f eat
.
We give some perspective of adapting neural network based
unsupervised language modeler [16]
to model
and find fea-
ture representation of a graph.
Assume a sequence of words
W = {w
0
, w
1
, · · · , w
n
}, where w
i
∈ V (V is the vocabulary)
and a paragraph P containing the sequence of words, a lan-
guage model maximizes Pr[w
n
|w
0
, w
1
, · · · , w
n−1
, P ] over all
the training corpus.
P can be thought of as another word,
which behaves as a memory that recalls what is missing from
the current context (w
0
, w
1
, · · · , w
n−1
).
When we map dfs-
walks as sentences,
estimated likelihood can be written as
Pr[v
i
|v
0
, v
1
, · · · , v
i−1
, d
walk
],
which is the likelihood of
ob-
serving a vertex v
i
in a walk given all the previously visited
vertices and the walk d
walk
.
Note that, v
i
in the likelihood
function does not necessary have to be at the end of
the
context (v
0
, v
1
, · · · , v
i−1
),
rather a context of a vertex con-
sists of vertices appearing to the left and right of the given
vertex in the dfs-walk.
The training of
word vectors and
paragraph vectors is done using stochastic gradient descent
and the gradient is obtained via back-propagation.
Please
see [16] for more detail of the method.
3.2
Classification Model
The PRIIME models the user’s interestingness profile over
the patterns as a classification problem and learns the model
parameters through an interactive feedback mechanism.
In
each iteration, PRIIME executes a supervised training ses-
sion of the classification model using the corresponding data
points of the released patterns to the user.
We use multino-
mial logistic regression as the classification model H
θ
, which
is known as softmax regression in the literature.
In multi-
nomial logistic regression,
the probability that a data point
x
i
∈
R
d
belongs to class j can be written as,
H
θ
(x
i
) = p(y
i
= j|x
i
; θ) =
exp(θ
j
T
x
i
)
P
c
l=1
exp(θ
l
T
x
i
)
(1)
where,
j ∈ {1, · · · , c} is the set of class labels and θ
j
is the
weight vector corresponding to class j.
The prediction of the
model
can be computed as,
ˆ
y
i
= argmax
j
p(y
i
= j|x
i
, θ).
Given a set of labeled training data X = {(x
1
, y
1
), .., (x
m
, y
m
)},
the weight matrix θ ∈ c × d (c is the number of
class and
d is the size of a feature vector) is computed by solving the
convex optimization problem as shown in Equation 2 using
gradient descent.
Note that, each data points x
i
∈
R
d
in the
training set corresponds to a pattern.
argmin
θ
J(θ) = −
1
m
m
X
i=1
c
X
j=1
1
{y
i
=j}
· log p(y
i
= j|x
i
; θ)
+
λ
2
c
X
j=1
d
X
k=1
θ
jk
(2)
Here J(θ) is the notation to represent the cost function
in Equation 2,
1
{y
i
=j}
is the indicator function indicating
that only the output of
the classifier corresponding to the
correct class label is included in the cost.
λ
2
P
c
j=1
P
d
k=1
θ
jk
is the regularization term to avoid over-fitting.
In each it-
eration,
PRIIME applies L-BFGS-B optimization function
implemented in python’s scipy package to train the model.
3.3
Selection of Representative Data-points for
Feedback
As discussed in Section 1, one of the reasons of the supe-
rior performance of our proposed method over the existing
ones is due to the exploitation-exploration based feedback
collection.
In each iteration,
for an incoming batch,
PRI-
IME exploits the currently learned model (M
cur
) to identify
the patterns that will have the largest impact on the parame-
ters of the learning model.
We can identify those patterns by
checking whether these patterns make the maximum change
in the objective function.
Since we train softmax classifier
using gradient descent, we include the patterns to the train-
ing set if it creates the greatest change in the gradient of the
objective function,
▽
θ
j
J(θ) = −
1
m
m
X
i=1

x
i
1
{y
i
=j}
− p(y
i
= j|x
i
; θ)

+ λθ
j
(3)
However,
gradient change computation requires the knowl-
edge of the label, which we don’t have.
So, we compute the
expected gradient length [27] of x
i
as shown in Equation 4,
EGL(x
i
) =
c
X
j=1
p(y
i
= j|x
i
; θ)|| ▽
θ
j
J (θ)||
(4)
After exploitation step, PRIIME retains the top 50% of pat-
terns (x
i
s) according to the expected gradient length (EGL)
as
candidates
for
feedback.
However,
Expected gradient
length based approach enables PRIIME to identify patterns
that can make greatest changes in the learning model,
but
it does not ensure diversity among the patterns in terms
of its composition, i.e.
two patterns can be made of similar
items, events or edges.
To ensures that a broader span of the
pattern space is covered, PRIIME uses k-center search (ex-
ploration) to identify k patterns for feedback from the can-
didates set.
k-Center.
k-center method finds k data points as centers
so that the maximum distance from each data point to its
nearest center is minimized.
This k-center problem is NP-
complete, but there exists a fast 2-approximation greedy al-
gorithm that solves this problem in O(kn) time [1].
We set k
to 10 in all our experiments.
For choosing 10 representative
patterns, we use the greedy 10-center algorithm considering
the Jaccard distance for set patterns and euclidean distance
for sequence and graph patterns.
3.4
Stopping Criteria
The stopping criterion is an important element of our pro-
posed system.
The execution of PRIIME can be halted from
the system side as well as the user side.
PRIIME sets a mini-
mum default iteration counts to 10 and after 10th iteration,
it keeps track whether getting additional
feedback impact
significantly on the learning model
or not.
If the improve-
ment falls below to a threshold (1E − 4),
the execution of
the feedback session halts.
# of
Avg.
Type
Dataset
trans-
transac-
ρ
min
|C|
actions
tion size
Chess
3196
37
2100
99262
Set
Mushroom
8124
22
1100
53628
EHR
10000
43
3000
104297
Drug-Side-effects
996
99
220
117544
Sequence
Reuters1
4335
56
86
54193
Reuters2
900
108
36
48209
Graph
PDB
416
15
8
9246
Mutagenicity-II
684
24
8
20771
Table 1:
Dataset Statistics
4.
EXPERIMENTS & RESULTS
4.1
Data
We use four set datasets, two sequence datasets, and two
graph datasets
to validate the performance of
PRIIME.
Two of
the set datasets,
Chess and Mushroom,
are real-life
datasets collected from FIMI
repository
2
.
The third one
is an artificially generated electronic health record (EHR)
dataset created by Uri
Kartoun from Harvard University
3
,
which has health record of
10, 000 patients.
To generate a
class label for each patient, we identify whether the patient
is diagnosed with arthritis, type-I/II diabetics or not
4
.
The
last set dataset is a drug side effects dataset collected from
CIDER repository
5
.
This data contains 996 drugs and asso-
ciated side effects.
We consider each drug as a transaction
and side effects as the items.
Each drug also has a class label
based on the primary disease which it cures:
cancer,
heart
diseases, brain diseases, pain, and others.
The two sequence dataset Reuters1 and Reuters2 is col-
lected according to the procedure mention in a sequence
classification work [36].
These datasets are prepared by ex-
tracting specific keywords from the entries in the Reuters-
21578 corpus
6
.
Reuters1 consists of word sequences labeled
by either “earn” or “acq”.
Reuters2 consists of
sequences
labeled by “interest”, “money-fx”, “crude” and “trade”.
For
more information see [36].
Out of
the two graph datasets,
one is called pdb, which is collected from predictive toxicol-
ogy challenge
7
.
The other graph dataset, Mutagenicity-II
is obtained from the authors of [8].
In Table 1,
we present
some basic statistics about these four datasets;
ρ
min
is the
minimum support threshold,
and C is the set of
all
closed
frequent patterns.
For each dataset,
we choose ρ
min
in a
way so that we can have a large number of closed frequent
patterns for the validation of the system.
4.2
Experimental Setup
An essential
part of
PRIIME is a pattern mining algo-
rithm that mines frequent patterns and send them to the
Learner in batches.
We use LCM [31], spmf [11] and CloSpan [34]
for mining closed set,
sequence and graph patterns,
recep-
tively.
A closed frequent pattern is defined as a pattern that
does not have a super-pattern (super-set) that is frequent
2
http://fimi.ua.ac.be/data/
3
http://bit.ly/1Db1yHo
4
Generally class label is not needed for pattern mining.
We
use the class labels to simulate user’s interestingness over
the patterns.
5
http://sideeffects.embl.de/download/
6
http://web.ist.utl.pt/˜acardoso/datasets/r8-train-stemmed.txt
7
http://www.predictive-toxicology.org/ptc/
with the same support count [35].
The set of closed pattern,
C,
is a subset of
the set of
frequent patterns,
O.
Redun-
dancy among the patterns in O is substantially reduced in
the patterns in C, so learning a function over the patterns in
C is better than learning a function over the patterns in O.
For performance evaluation, we make 5-folds of the data of
which 4 folds are used for interactive training and 1 fold for
testing.
We use a grid search to tune regularization param-
eter λ and set it to 1.
We run Gensim’s [24] implementation
of Paragraph Vector model with the default parameter set-
tings,
except for the parameter d (the dimension of feature
vector), which we set it to 100 for both sequence and graph
after tuning it using grid search.
We report the performance
result using average weighted F-score (calculate F-Score for
each label, and compute their average, weighted by the num-
ber of true instances for each label) over the folds.
In each
iteration,
we approximately use 2% of the training data to
construct the batch and select 10 patterns from the batch
for feedback.
Note that in the first iteration, PRIIME uses
the k-center search to find 10 patterns for feedback.
We im-
plement PRIIME in python and run all
experiments in 3
GHz Intel machine with 8GB memory.
4.3
Interestingness Criteria
Following earlier works [33, 4], for validating the proposed
system we simulate the interestingness function of
a user.
The interestingness criteria of a pattern is derived from the
class label
of its predominating transactions.
For example,
if
a pattern p belongs to t number of
transactions among
which t
1
and t
2
are the numbers of transactions with label
1 and 2 respectively;
then t = t
1
+ t
2
.
The corresponding
label/feedback of p is measured as 1 if max(t
1
, t
2
) = t
1
else
2.
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Weighted F-Score
Iterations of Feedback
Set Patterns
Mushroom, 2 class
Chess, 2 class
EHR, 3 class
Side-Effects, 5 class
Figure 5:
Weighted F-Score of the learner across iterations
of feedback in set dataset
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Weighted F-Score
Iterations of Feedback
Sequence Patterns
Reuters1, 2 class
Reuters2, 4 class
Figure 6:
Weighted F-Score of the learner across iterations
of feedback in sequence dataset
4.4
Experiment on the Learner’s Performance
In this experiment,
we evaluate the performance of soft-
max based learning algorithm using weighted F-Score met-
ric.
we show how the performance of
the learning model
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Weighted F-Score
Iterations of Feedback
Graph Patterns
Mutagenicity-II, 2 class
PDB, 2 class
Figure 7:
Weighted F-Score of the learner across iterations
of feedback in graph dataset
improves with the iterations of feedback.
As discussed ear-
lier in each iteration,
the learner selects ten patterns for
feedback and iteratively updates the current model.
After
each iteration, we measure weighted F-Score of our currently
learned model with the test fold.
Then we plot F-score of the
learner across the number of iterations executed so far.
In
Figure 5, 6 and 7, we show the progression of F-score across
iterations for the set,
sequence and graph datasets.
The
performance on set and sequence datasets is relatively bet-
ter than that on graph datasets.
The reason behind this is
that effective feature vector construction for graph patterns
is comparatively difficult than set and sequence patterns.
For all the datasets, within five to ten iterations of feedback
(each iteration has 10 patterns), learning method converges
and stay stable.
Compared to the entire (closed) frequent
pattern space, the number of feedback that PRIIME use is
almost negligible, yet the performance of the learning model
is satisfactory.
Dataset
Accuracy
Accuracy
Accuracy
PRIIME’s
([33]’s)
[4]’s
Chess
90.8 %
42.7%
55.5%
Mushroom
84.5%
45.3%
61.4%
EHR
78.8%
46.6%
40.6%
Drug-Side-Effects
71.9%
36.3%
54.50%
Reuters1
91.1%
35.9%
NA
Reuters2
76.6%
38.2%
NA
PDB
73.1%
NA
50.7%
Mutagenicity-II
66.8%
NA
44.7%
Table 2:
Comparison on percentage accuracy of
our algo-
rithm with the existing ones
4.5
Comparison with the Existing Algorithms
To compare with the existing works we implement [33]’s
interactive learning method in python and compute the per-
centage accuracy experiment of
their method for
the set
and sequence data by following the instructions provided
in the paper [33].
We also compare with [4]’s sampling algo-
rithm (executable collected from the authors) for the set and
graph data; we pick sampler’s recall metric mentioned in [4]
as it computes the percentage of interesting patterns recov-
ered by the sampler.
For all algorithms, we use 100 feedback
and use the percentage of accuracy as a comparative metric.
Table 2 shows the comparison,
which clearly demonstrates
that our algorithm performs substantially better than the
existing methods.
We validate that this performance boost
can be credited to efficient feature construction for complex
patterns and intelligent exploitation-exploration strategy for
feedback pattern selection.
We will
discuss more on this in
the following sections.
Reuters1
Reuters2
PDB
Muta-II
Dataset
0.0
0.2
0.4
0.6
0.8
1.0
Weighted F-Score
Performance of Deep Unsupervised Feature Construction
n-gram
NN based
metric
Figure 8:
Performance of
Deep Unsupervised feature con-
struction.
4.6
Comparison of Unsupervised Feature Learn-
ing Approach with Others
In this experiment,
we evaluate the effectiveness of
the
proposed unsupervised feature construction based approach
with alternative feature representation for sequence and graph
patterns.
For sequence pattern, we use n-gram based tech-
nique,
where we extract all
2-grams and 3-grams from the
data and use those as features.
For graph patterns,
we ob-
tain 20 topological
metrics compiled by [17]
and consider
these metrics as features for graph patterns.
We run PRI-
IME for 10 iterative sessions (100 feedback) and use the
weighted F-score for comparison.
In figure 8,
we show the
findings using bar chart.
First two groups of the bar chart
are for sequence datasets and the remaining two groups are
for graph datasets.
As we can see, PRIIME’s unsupervised
feature learning performs better than the alternative feature
representation of both sequence and graph patterns.
Specif-
ically,
PRIIME’s feature embedding for graph datasets is
significantly better than that of the competitors’.
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Micro F-Score
Iterations of Feedback
Mushroom Data (Set Patterns)
Version 1
Version 2
Version 3
Version 4
Figure 9:
Performance of the learner with different feedback
collection scheme in Mushroom set dataset
4.7
Representative Patterns Selection
As discussed in Section 1,
our proposed solution is dif-
ferent than the existing works on how we select patterns
for
feedback.
To show that
our approach is
more effec-
tive,
we create four different versions of PRIIME .
In one,
we solely rely on exploitation i.e pick top 10 patterns for
feedback from a batch according to the expected gradient
length (EGL). In second, we concentrate on exploration and
select 10 most diverse patterns for feedback using only k-
center from the entire batch.
The third version is the one
that we proposed in this work,
where we retain top 50%
patterns from a batch according to the EGL then apply k-
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Micro F-Score
Iterations of Feedback
Reuters1 Data (Sequence Patterns)
Version 1
Version 2
Version 3
Version 4
Figure 10:
Performance of
the learner with different feed-
back collection scheme in Reuters1 sequence dataset
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Micro F-Score
Iterations of Feedback
Mutagenicity-II (Graph Patterns)
Version 1
Version 2
Version 3
Version 4
Figure 11:
Performance of
the learner with different feed-
back collection scheme in Mutagenicity-II graph dataset
center to find 10 most diverse patterns for feedback.
In
fourth, we use only k-center (exploration) in the first 10 in-
teractive sessions, then we use the combination of EGL and
k-center (exploitation-exploration) like third version for the
next 10 iterations,
and in final
10 iterations,
we only use
EGL (exploitation).
In Figure 9,
10 and 11,
we show the
performance of the above four versions of PRIIME for a set,
sequence,
and graph data.
As we can see,
for all
the cases,
our proposed exploitation-exploration (Version 3 curve in
the figures) strategy performs better than the other three
options.
Our’s performance better than the fourth version
(Version 4 in the figures) establish the fact that in interactive
pattern discovery, balancing exploration and exploitation in
all
iterations of learning is beneficial than gradually chang-
ing from exploration to exploitation like the fourth version.
More importantly, the performance of the learning methods
that solely depends on the current learning (Version 1 in the
Figures) is the lowest among all
three,
which suggests that
high exploitation of the current model for selecting patterns
for feedback may yield sub-optimal model.
5.
CASE STUDY
To demonstrate the applicability of interactive personal-
ized interesting pattern discovery in a real world setting, we
perform a case study in the real-estate domain.
Generally,
the success of a home searching process depends on a user’s
ability to construct a well-defined search query.
It also de-
pends on her patience while going through the hundreds of
houses that are returned by the search engine.
This assess-
ment is particularly challenging for new home buyers,
who
are, sometimes not even familiar with all different home fea-
tures.
The overall process of selecting the right home takes
time;
actually,
for 40% of
first time home buyers,
the lag
time between research and action (buying a home) is around
120 days [12].
Given that home buying is a significant in-
vestment,
most home buyers take help from an experience
real estate agent who can read the buyer’s mind as soon as
possible and show her the home that is just right for her.
PRIIME in this setup works just like a virtual
real
es-
tate agent for the home buyers;
where each house can be
thought of
as a set type transaction and house features as
the items in the transaction.
In each iteration,
PRIIME
presents a set of frequent patterns which are a summary set
of features of the houses in the data.
By utilizing the feed-
back over the quality of patterns PRIIME gradually learns
the user’s interestingness criteria on the house features.
Fi-
nally, using the learned model PRIIME identifies the house
summaries (patterns) as well as the houses that the user will
prefer.
In the following,
we will
explain in detail
from the
data collection, experimental setup, and observations.
5.1
Data
We crawl
trulia.com from November 2015 to January
2016 (3 months) for five major cities:
Carmel, Fishers, In-
dianapolis,
Zionsville and Noblesville in the Central
Indiana.
The information that we crawl
is the basic house
information,
text on house detail,
school,
and crime infor-
mation.
In total, we crawl 7216 houses among which 596 are
from Carmel, 525 are from Fishers, 5485 are from Indianapo-
lis, 211 are from Zionsville and 389 are from Noblesville.
We
choose Central
Indiana home market because of our famil-
iarity with the region.
To clean the crawled text data we use standardized data
cleaning approach,
i.e.
remove stop words,
stemming and
lemmatization of
words.
We have manually cleaned some
keywords that are written in unstructured abbreviated form.
For example,
keyword fireplace is written as frplc,
or
firplc in many house details.
In order to compile house
features set, we use Rake [25] to find the key phrases.
Next
we group the key phrases, where we keep two key phrases to-
gether if they share at least one keyword.
That way, we get
all the features of a category together.
For example, all the
key phrases related to basement grouped together.
Finally,
we manually investigate these groups and identify specific
house features.
In the end,
we retain only those house fea-
tures that appear in at least ten (10) houses.
The total num-
ber of house features we extracted from the crawled data is
130 that includes interior features,
neighborhood features,
and school information.
5.2
Setup
We empirically evaluate PRIIME by demonstrating its
performance over a demographic group of home buyers.
We
identified a group from the yearly report of realtor.com [21]
and populate a potential house features set that this group
might like.
The group is a median-income couple with kids.
People in this demographic group are of age between 35 to
49.
We select first 4 features related to the type of a house
and nearby schools quality.
Next 3 features related to the
neighborhood of a house.
Third set of features are related to
the interior of a house.
According to the report [21], 85% of
the peoples in the group prefer single family home and 43%
of
the individuals in this group want good quality nearby
schools, so we select Single Family Home, Nearby schools,
Above Average Quality Primary School,
and Above Av-
erage Quality Middle School as house features.
24% of
families with kids prefer nearby parks,
playground,
so we
pick Neighborhood playground,
Trails,
Community pool
and Lowest crime rate.
50% of this demography have kids
and most likely they prefer houses with open concept de-
sign,
spacious,
easy to maintain,
common and work area,
and large kitchen with necessary amenities.
With that in
mind, we pick, Open concept,
4 Bedrooms,
3 Bathrooms,
2
car garage,
finished basement,
Large Master Bedroom,
Hardwood floor, Open Concept kitchen,
Stainless-steel appliance, Granite countertop and is-
land,
Dual sink, Many cabinets,
Common area, Work area
and Large backyard.
0
0.2
0.4
0.6
0.8
1
0
5
10
15
20
25
30
Weighted F-Score
Iterations of Feedback
PRIIME’s Performance
Case Study
Figure 12:
Performance of the learner for the Demographic
Group
-1
-0.5
0
0.5
1
1.5
Feature Weight
Features
PRIIME’s Learning
Figure 13:
Quality of Training on the Demographic Group
5.3
Experiment and Observations
After generating features set associated with the demo-
graphic group, we first create labels for the mined closed pat-
terns from the data with 5% support.
We assign label 1 (in-
teresting) to a pattern if
it contains 80% or more features
from the devised features set, otherwise 0 (non-interesting).
Next, we split the patterns set into train and test and exe-
cute PRIIME over the training split.
We set the batch size
to 2000 and consider 10 patterns for feedback in each itera-
tion.
We measure the classification performance of PRIIME
in terms of weighted F-Score.
First,
we observe how PRIIME’s
performance changes
with the interactive sessions.
In Figure 12,
we plot PRI-
IME’s
performance using weighted F-Score over the test
data in the y-axis,
and plot iterations count of
PRIIME
in the x-axis.
As we can see,
the performance of
the sys-
tem improves with iterations of
feedback.
After 5 itera-
tions, PRIIME reaches to a reasonable performance with a
Weighted F-Score higher than 0.8.
PRIIME reaches to a
stable position in terms of performance after 10 iterations.
To illustrate the training quality of the learning module in
PRIIME, we create a bar chart with the feature weights of
the model.
To visually show the distinction between weights
of the selected features set from the weight of the rest of the
features, we divide the plotting area into two regions, in the
left region we display the weights of the selected features set
in red ink and in the right region we show the weight of the
rest of the features in blue ink.
As we can see in Figure 13,
PRIIME puts positive weights on the features from the se-
lected set and negative weight to the majority of other fea-
tures.
Few features in the right side of the plot have positive
weight and we found that top two (according to weight) of
these features are many windows and counter space which
are related to the selected open concept and open concept
kitchen feature.
Note that,
the learned features weights
used in the bar chart is collected after 10 iterations.
6.
RELATED WORKS
There exist a few works which target personalized pattern
discovery by using users feedback.
In [33]
the authors pro-
pose a model that learns a user’s ranking function over the
frequent itemsets.
They start with the entire set of
closed
frequent itemsets, and send users a small list of patterns; the
user provides a complete ordering among the patterns which
the model
uses
as
constraints
in an SVM ranking based
model.
The model
chooses the next batch of
patterns for
feedback using the learned SVM ranking model.
Bhuiyan
et al. [4] propose another interactive pattern mining frame-
work, where the user interacts with a Markov Chain Monte
Carlo (MCMC) sampling entity, which samples frequent pat-
terns from hidden data.
The target distribution of the sam-
pler is iteratively refined based on binary feedback from the
user.
Boley et al.
[6]
propose a co-active based approach
for interactive pattern mining, which use user’s feedback to
decide between searching and sampling of patterns from the
output set.
There also exist a few other works [18],
which
mine a small
set of
interesting patterns by defining novel
interestingness metrics for frequent patterns.
For instance,
Mampaey et al.[18] summarizes the frequent pattern set and
Blei
et.
al.[5]
defines subjective interestingness,
both using
maximum entropy model.
[14] develops a toolbox with inter-
estingness measures, mining and post-processing algorithms
as built-ins that can assist a user to visually mine interest-
ing patterns.
However, the scope of these works is different
than our work.
There are some recent
works
on interactive knowledge
discovery which solves
domain specific problems.
Exam-
ples include mining geospatial
redescriptions [13],
and sub-
group discovery [10,
22].
In the work on mining geospa-
tial redescriptions
[13], the authors propose a system called
SIREN, in which a user builds queries based on his interests
and the system answers the queries through visualization
of redescriptions (different ways of characterizing the same
things).
In [10, 22], the authors present a framework which
utilizes user’s feedback and devises a search procedure for
finding subgroups.
7.
CONCLUSION
In this work, we propose a generic framework of interactive
personalized interesting pattern discovery called PRIIME.
The proposed method uses user’s rating on a small collection
of
patterns for learning a user profile model,
which at a
later stage can be used for recommending patterns that best
align with user’s interests.
Such a method is highly useful
for identifying a small number of interesting patterns where
interestingness is defined through user’s rating.
8.
REFERENCES
[1]
Clustering to minimize the maximum intercluster
distance. Theoretical
Computer Science,
38(0):293–306,
1985.
[2]
C. C. Aggarwal. Data classification:
algorithms and
applications. CRC Press, 2014.
[3]
R. Agrawal and R. Srikant. Fast algorithms for mining
association rules in large databases. In Proc. of
VLDB, pages 487–499,
1994.
[4]
M. Bhuiyan, S. Mukhopadhyay, and M. A. Hasan.
Interactive pattern mining on hidden data:
A
sampling-based solution. In Proceedings of the 21st
ACM CIKM, pages 95–104,
2012.
[5]
T. D. Bie. Maximum entropy models and subjective
interestingness:
an application to tiles in binary
databases. Data Mining and Knowledge Discovery.
[6]
M. Boley, M. Mampaey, B. Kang, P. Tokmakov, and
S. Wrobel. One click mining-interactive local pattern
discovery through implicit preference and performance
learning. In KDD 2013 Workshop IDEA, 2013.
[7]
A. Bondu, V. Lemaire, and M. Boulle. Exploration vs.
exploitation in active learning :
A bayesian approach.
In Int. Joint Conf. on Neural
Networks, pages 1–7,
2010.
[8]
S. Bringmann, A. Zimmermann, L. Raedt, and
S. Nijssen. Don’t be afraid of simpler pattern. In
PKDD, pages 55–66, 2004.
[9]
D. Ciresan, U. Meier, and J. Schmidhuber.
Multi-column deep neural networks for image
classification. In Computer Vision and Pattern
Recognition (CVPR), 2012 IEEE Conference on,
pages 3642–3649,
2012.
[10]
V. Dzyuba and M. van Leeuwen. Interactive discovery
of interesting subgroup sets. In Advances in Intelligent
Data Analysis XII, volume 8207, pages 150–161.
2013.
[11]
P. Fournier-Viger, A. Gomariz, T. Gueniche,
A. Soltani, C. Wu., and V. S. Tseng. SPMF: a Java
Open-Source Pattern Mining Library. Journal
of ML
Research (JMLR), 15:3389–3393,
2014.
[12]
A. J. S. from The National Association of Realtors
ˆ
A˝o
and Google.
The digital house hunt:
Consumer and
market trends in real estate. National
Association of
Realtors, 2013.
[13]
E. Galbrun and P. Miettinen. Siren:
An interactive
tool for mining and visualizing geospatial
redescriptions. In Proceedings of the 18th ACM
SIGKDD, pages 1544–1547,
2012.
[14]
B. Goethals, S. Moens, and J. Vreeken. Mime:
A
framework for interactive visual pattern mining. In
ECML, pages 757 –760, 2011.
[15]
M. A. Hasan and M. J. Zaki. Output space sampling
for graph patterns. In Proc. of VLDB, pages 730–741,
2009.
[16]
Q. V. Le and T. Mikolov. Distributed representations
of sentences and documents. arXiv preprint
arXiv:1405.4053, 2014.
[17]
G. Li, M. Semerci, B. Yener, and M. J. Zaki. Effective
graph classification based on topological
and label
attributes. Stat. Anal. Data Min., 5(4):265–283,
2012.
[18]
M. Mampaey, N. Tatti, and J. Vreeken. Tell me what i
need to know:
succinctly summarizing data with
itemsets. In Proc. of the 17th ACM SIGKDD.
[19]
M. Mampaey, J. Vreeken, and N. Tatti. Summarizing
data succinctly with the most informative itemsets.
ACM Trans. Knowl. Discov. Data, 6(4):16:1–16:42,
2012.
[20]
T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and
J. Dean. Distributed representations of words and
phrases and their compositionality. In Advances in
Neural
Information Processing Systems 26, pages
3111–3119.
2013.
[21]
T. N. A. of Realtors. 2015 home buyer and seller
generational trends.
[22]
B. Omidvar-Tehrani, S. Amer-Yahia, and A. Termier.
Interactive user group analysis. In Proceedings of the
24th CIKM, pages 403–412,
2015.
[23]
B. Perozzi, R. Al-Rfou, and S. Skiena. Deepwalk:
Online learning of social
representations. In
Proceedings of the 20th ACM SIGKDD.
[24]
R.
ˇ
Reh˚uˇrek and P. Sojka. Software Framework for
Topic Modelling with Large Corpora. In Proceedings
of the LREC 2010 Workshop on New Challenges for
NLP Frameworks,
pages 45–50.
[25]
S. Rose, D. Engel, N. Cramer, and W. Cowley.
Automatic keyword extraction from individual
documents. Text Mining, pages 1–20, 2010.
[26]
B. Settles. Active learning literature survey. University
of Wisconsin, Madison, 52(55-66):11,
2010.
[27]
B. Settles, M. Craven, and S. Ray. Multiple-instance
active learning. In Advances in Neural
Information
Processing Systems 20, pages 1289–1296.
2008.
[28]
P. Simard, D. Steinkraus, and J. C. Platt. Best
practices for convolutional neural networks applied to
visual document analysis. In Document Analysis and
Recognition, 2003. Proceedings. Seventh International
Conference on, pages 958–963,
2003.
[29]
R. Socher, E. H. Huang, J. Pennin, C. D. Manning,
and A. Y. Ng. Dynamic pooling and unfolding
recursive autoencoders for paraphrase detection. In
Advances in Neural
Information Processing Systems,
pages 801–809,
2011.
[30]
C. Szegedy, W. Liu, Y. Jia, P. Sermanet, S. Reed,
D. Anguelov, D. Erhan, V. Vanhoucke, and
A. Rabinovich. Going deeper with convolutions.
CoRR, abs/1409.4842,
2014.
[31]
T. Uno, M. Kiyomi, and H. Arimura. Lcm ver. 2:
Efficient mining algorithms for
frequent/closed/maximal itemsets. In Proc. IEEE
ICDM’04 Workshop FIMI’04, 2004.
[32]
J. Vreeken, M. Leeuwen, and A. Siebes. Krimp:
Mining itemsets that compress. Data Min. Knowl.
Discov., 23(1):169–214,
2011.
[33]
D. Xin, X. Shen, Q. Mei, and J. Han. Discovering
interesting patterns through user’s interactive
feedback. In Proc. of the 12th ACM SIGKDD, pages
773–778,
2006.
[34]
X. Yan, J. Han, and R. Afshar. Clospan:
Mining
closed sequential patterns in large datasets. In In
SDM, pages 166–177.
SIAM, 2003.
[35]
M. J. Zaki and J. Wagner Meira. Data Mining and
Analysis:
Fundamental
Concepts and Algorithms.
Cambridge University Press, 2014.
[36]
C. Zhou, B. Cule, and B. Goethals. Itemset based
sequence classification. In Machine Learning and
Knowledge Discovery in Databases,
pages 353–368.
Springer, 2013.
