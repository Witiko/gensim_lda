Exploiting Unlabeled Data for
Neural Grammatical Error Detection
Zhuoran Liu
†
and Yang Liu
‡
†
School of Software, Beihang University, Beijing
‡
Department of Computer Science and Technology, Tsinghua University, Beijing
liuzhuoran17@163.com, liuyang2011@tsinghua.edu.cn
Abstract
Identifying and correcting grammatical errors in the text written by non-native writers has received increasing
attention in recent years. Although a number of annotated corpora have been established to facilitate data-driven
grammatical error detection and correction approaches, they are still limited in terms of quantity and coverage
because human annotation is labor-intensive, time-consuming, and expensive. In this work, we propose to utilize
unlabeled data to train neural network based grammatical error detection models. The basic idea is to cast error de-
tection as a binary classification problem and derive positive and negative training examples from unlabeled data.
We introduce an attention-based neural network to capture long-distance dependencies that influence the word
being detected. Experiments show that the proposed approach significantly outperforms SVMs and convolutional
networks with fixed-size context window.
1
Introduction
Automatic grammatical error detection and correction for natural languages has attracted increasing attention, for
a large number of non-native speakers are learning or using foreign languages. Take English as an example. There
are a large number of English learners around the world who need instantaneous accurate feedback to help improve
their writings (Dahlmeier and Ng [2012]). In the domain of scientific paper writing in which English is the main
language, authors also need effective grammar checkers to help them in composing scientific articles (Ford [2015]).
There have been several shared tasks addressing grammar errors in recent years. HOO-2011 (Dale and Kilgar-
riff [2011]), HOO-2012 (Dale, Anisimoff, and Narroway [2012]), CoNLL-2013 (Ng et al. [2013]) and CoNLL-
2014 (Ng et al. [2014]) shared tasks all aimed to correct grammar errors. The AESW shared task (Daudaravicius
et al. [2016]) aimed to identify sentence-level grammar error. These shared tasks helped advanced the research of
grammatical error detection or correction.
Despite these advances, the scarcity of annotated data is still a major limitation on research of grammatical error
detection and correction. Researchers need mass annotated data to train a grammar checker, but unfortunately for
them, there are only a small amount of annotated corpora available in a limited number of domains. Most annotated
corpora are in the domain of learner English, e.g. NUCLE (Dahlmeier, Ng, and Wu [2013]) and CLC (Nicholls
[2003]), and others are from domains such as scientific papers, e.g. AESW dataset (Ford [2015]). In order to train
their system with enough data, researchers use multiple corpus instead of one (Felice et al. [2014]).
Data scarcity is partly due to difficulties in building an elaborately annotated corpus needed for training of
a grammatical
error correction system,
as is described by the team that
built
NUS Corpus of Learner English
1
arXiv:1611.08987v2 [cs.CL] 29 Nov 2016
(Dahlmeier, Ng, and Wu [2013]). In order to obtain a reliable annotation, they set up a guideline for annotators so
that corrections are consistent. To ensure that these annotations are available, several annotators proposed their cor-
rection independently, and annotations most agreed upon are selected. Such annotating process is labour-intensive
and time consuming, and the quality of the corpus are subject to human judgment and other factors such as budget.
For example, their team is unable to perform double annotation for the main corpus due to budget constraints. They
spent a long time (over half a year) to annotate only 1,414 essays.
Given these difficulties in building annotated corpus, we hope to utilize un-annotated error-free texts in unsu-
pervised training of a grammatical error correction or grammatical error detection system. Previously, efforts have
been made to explore how realistic grammatical errors could be counterfeited automatically from error-free texts
and therefore obtain large amount of annotated data (Felice and Yuan [2014]; Foster and Andersen [2009]; Lee
and Lee [2009]; Imamura et al. [2012]). We therefore follow the idea of building a corpus by generating artificial
error, since there are vast amount of un-annotated texts available and most of them are error-free. We explored two
ways of artificial error generation, which is proved to be effective in our experiment.
Training a system to correct grammatical errors might be a more difficult task when there is no supervision,
since there are numerous error types and our method to generate artificial errors might not be sophisticated enough
to cover all of them. We thus focus on grammatical error detection instead of correction. It is natural to address
this task as binary classification, in which we make prediction of whether a word is grammatically correct.
2
Background
2.1
Problem Statement
The goal of word-level grammatical error detection is to identify grammar errors at the word level. For example,
given a sentence shown below, a grammatical error detection system is expected to correctly identify the erroneous
word ‘birds’ highlighted by underline:
An ugly birds was observed by the man yesterday .
The task of word-level grammatical error detection is formalized as such: given a sequence of token
X =
(x
1
, x
2
, ..., x
n
)
as input, the error detector outputs its prediction
Y = (y
1
, y
2
, ..., y
n
)
where
y
i
denotes the correct-
ness of
x
i
in terms of grammaticality.
We address this problem as a binary classification problem. In order to predict
y
t
given the current word
x
t
and
the whole sentence
X = (x
1
, x
2
, ..., x
n
)
, we need to find a function
g(·)
to calculate the conditional probability of
each
y
t
given
x
t
and the whole input sequence
X
:
p(y
t
|x
t
) = g(x
t
, X),
(1)
where
y
t
=

1
correct
0
incorrect
.
(2)
Our aim is to build a suitable classification model for
g(·)
.
2.2
Support Vector Machines
A natural approach is to use Support Vector Machine (SVM) to perform classification (Boser, Guyon, and Vapnik
[1992]; Cortes and Vapnik [1995]). SVM is trained given a training dataset in the form of
{(x
1
, y
1
), ..., (x
n
, y
n
)}
,
2
where
x
i
represents a token with a set of selected linguistic features, and
y
i
denotes the grammatical correctness
of the token. It finds a maximum-margin hyperplane that separates correct words from incorrect ones.
The problem with this approach is that we need to manually design features in
x
i
.
Since human are unable
to tell precisely which features are relevant, human-designed features are inadequate in some aspects while being
redundant in others. As a result, these designed features are unable to capture all regularities, which might hurt the
performance of our error detector.
2.3
Convolution Network with Fixed Window Size
To circumvent the problem with feature engineering, a natural thought is to utilize the capability of neural networks
in automatic feature extraction (Collobert and Weston [2008]).
The simplest way is to take into consideration a
fixed size window of words around the current word as its context by applying temporal convolution over the fixed
size window. In the example sentence given in Section 2.1, when considering the grammatical correctness of the
word ‘was’ given a context window of size 3, the context window would be birds was observed. The assumption
that underlies this method is that only neighbouring words are grammatically related to the current word.
Here we formalize the method of neural network with fixed size window. Given a word
x
i
, its context
c
i
is
c
i
= (x
i−w/2
, ..., x
i
, ..., x
i+w/2
).
(3)
Let
f (·)
denote a temporal convolution operation with the input frame size equal to the dimension of
x
i
, the
output frame size equal to
1
, and the kernel width equal to the size of fixed window. A score
s
i
of the current word
x
i
is calculated by
s
i
= f (c
i
)
which represents grammatical features within the window.
This score then goes
through a sigmoid layer and yield the probability of
y
i
:
p(y
i
|x
i
, c
i
) = σ(s
i
)
.
The first problem with this method is that it is incapable of capturing long-distance dependency. With a fixed
window size, the error detector is unable to take into consideration word contexts beyond the window size, while
long-distance grammatical dependency is quite common a phenomena. For example, in order to determine whether
‘was’ is incorrect,
we would need to take ‘yesterday’ into consideration,
which requires a large size of context
window.
Another problem with this approach is that all words within the context window is taken into consideration
indiscriminately. In the example above, ‘was’ might not care about what was done to the birds when determining
the verb tense, but ‘observed’ is given equal attention regardless of the fact that it has no influence on verb tense.
3
Approach
In this section we describe our unsupervised approach to word-level grammatical error detection.
3.1
Model Architecture
Our intuition is to first encode the input sequence into a sequence of hidden states which contain relevant grammat-
ical information, and then make prediction given a word and its context (see Figure.1). Thus our model consists of
two parts: an encoder that adopts a typical architecture of bi-directional LSTM network (Hochreiter and Schmid-
huber [1997]), and a classifier that makes predictions based on hidden states of the encoder.
3
Figure 1:
Model
Architecture.
The input
of the network is a sentence An ugly birds was observed by the man
yesterday .
in the form of one-hot
representation.
The representation is then converted into continuous word-
embeddings and encoded by a bi-directional
LSTM encoder.
These encoded information is reweighted by an
intra-attention mechanism at each time-step, on which the classifier judges the grammaticality of each word.
4
3.1.1
Encoder
The encoder takes as input a sentence
S
of length
n
, represented by a sequence of vector
X = (x
1
, x
2
, ..., x
n
)
. In
an LSTM recurrent neural network, the input
X
is processed through time and produces a series of memory states
(c
1
, c
2
, ..., c
n
)
and hidden states
(h
1
, h
2
, ..., h
n
)
. In order to counterbalance the impact of time on hidden states we
process the input
X
two times, forward and backward, to fully encode the information classifier needs.
The forward LSTM updates its memory state
−
→
c
i
and hidden state
−
→
h
i
at each time step
t
:
[
−
→
h
t
;
−
→
c
t
] =
−−−−→
LST M([
−−→
h
t−1
;
−−→
c
t−1
]).
(4)
Similarly, memory state
←−
c
i
and hidden state
←−
h
i
is updated by backward LSTM at time step
t
:
[
←−
h
t
;
←−
c
t
] =
←−−−−
LST M([
←−−
h
t+1
;
←−−
c
t+1
]).
(5)
The encoder outputs a hidden tape
e
h = (
f
h
1
,
f
h
2
, ...,
f
h
n
)
, where
e
h
t
=
"
−
→
h
t
←−
h
t
#
.
(6)
3.1.2
Classifier with Intra-attention
To predict whether the word at time step
t
is grammatically problematic, the classifier computes a score given the
current word
x
t
and its context
a
t
. This score
s
t
then goes through a sigmoid layer and makes a binary prediction,
with 1 denoting grammatically correct and 0 denoting incorrect. Note that the Classifier does not hold its own state
as a decoder does in a traditional encoder-decoder architecture.
To address the problem of long-distance dependency,
we incorporate an intra-sentence attention mechanism
(Bahdanau, Cho, and Bengio [2014]) in our classifier, where all hidden states of encoder is taken into consideration
and the attention of classifier on all position of the sentence is dynamically adapted.
To describe formally,
we
compute the context
a
t
around the word
x
t
as an attention-weighted sum of
{
f
h
1
,
f
h
2
, ...,
f
h
n
}
:
a
t
=
X
i
α
t,i
·
e
h
i
,
(7)
where
α
t,i
=
exp(E
t,i
)
P
j
exp(E
t,j
)
,
(8)
E
t,i
=
e
h
t
>
·
e
h
i
.
(9)
Vector
a
t
represents the grammatical and semantic context at position
t
. A word is considered to be grammat-
ically erroneous if the word
x
t
does not fit into the current context, i.e. it is incompatible to place
x
t
at position
t
given the context
a
t
. The score
s
t
is computed as follows:
s
t
= x
>
t
· W · a
t
+ b.
(10)
where
b
is the bias.
Then the probability can be calculated as
p(y|x
t
, {x
1
, x
2
, ..., x
n
}) = σ(s
t
).
(11)
5
By incorporating intra-attention mechanism, we provide a latent structure for the model to learn grammatical
relations between words. This makes a lot of sense because the grammaticality of a word is dependent more on
the words that have strong grammatical relation with it, while others are negligible when making prediction. For
example in Figure.1, when the model tries to determine whether ‘birds’ is correct in terms of noun number, it will
pay a strong attention to ‘An’.
3.2
Noise Generation
Traditionally,
a large set
of
{hX
(n)
, Y
(n)
i}
N
n=1
is needed to effectively train such a grammatical
error detec-
tor.
However in an unsupervised approach,
only
{X
(n)
}
N
n=1
is given.
The key issue is how the corresponding
{Y
(n)
}
N
n=1
could be obtained.
We adopted the idea of using artificial error for training. It is crucial to find a suitable algorithm for the error
generator to produce realistic grammatical error, since the performance of the model relies heavily on the paradigm
it saw during training. Since our task is to detect grammatical error on word level, we only consider substitution
errors. We compare two ways of substituting the original word for an erroneous one.
3.2.1
Uniform random substitution
The simplest way is to substitute a word in a random position with a random word from the vocabulary. The prob-
lem with this approach is that some artificial errors generated in this way is apparently irrelevant. For example, it
could substitute a word from the sentence
An ugly bird was observed by the man yesterday .
to generate such a sentence as
An ugly bird was vocabulary by the man yesterday .
One potential problem is that it might be too easy for our classifier to discriminate such erroneous words from
the correct ones.
Algorithm 1 Build Substitution Set
PoS-tag the input text
Build a dictionary
D
of (token, PoS-tag)
for all
(token, pos)
in
D
do
if
pos
in
{
CC
}
or
{
DT, PDT
}
or
{
PRP, PRP$
}
or
{
IN, TO, RP
}
or
{
WDT, WP, WP$, WRB
}
then
Add
token
to the corresponding substitution set
c
i
else if
pos
in
{
NN, NNP, NNPS, NNS
}
or
{
VB, VBD, VBG, VBN, VBP, VBZ
}
then
lemma ←
Lemmatise
token
Add
token
to the corresponding substitution set
c
i
else if
pos
in
{
JJ, JJR, JJS
}
or
{
RB, RBR, RBS
}
then
stem ←
Stem
token
Add
token
to the corresponding substitution set
c
i
end if
end for
6
Algorithm 2 Error generation
for all sentence
S
in training text do
Get word
w
at random position of
S
w
0
← w
Search for substitution set
c
i
that contains
w
if such
c
i
does not exist or
c
i
contains only 1 element then
while
w
0
== w
do
w
0
←
Select a random word from dictionary
D
end while
else
while
w
0
== w
do
w
0
←
Select a random word from
c
i
end while
end if
Replace
w
in
S
with
w
0
end for
POS tag
Original Word
Noise
Example
VB
built
build, builds, building, ...
Workers built the park centuries ago .
Workers build the park centuries ago .
NN
eggs
egg
All eggs were put into the same basket .
All egg were put into the same basket .
DT
an
a, this, these, ...
There is an apple on the table .
There is a apple on the table .
RB
suitably
suitable
Candidates
must
be suitably qualified stu-
dents.
Candidates
must
be suitable qualified stu-
dents.
IN
of
in, by, for, at, ...
This book consists of 12 chapters .
This book consists by 12 chapters .
Table 1: Examples of substitution with linguistic knowledge.
3.2.2
Substitution with linguistic knowledge
We carefully examined a number of erroneous paradigms and found some characteristics common to all gram-
matical errors, regardless of the terminology and commonly seen patterns of the domain. To briefly summarize it,
errors usually appears when a correct word is substituted by another word, which comes from a finite set of words
and that are linguistically related to it,
either because they possess the same lemma or the same part-of-speech
tag. There is an inexhaustible list of how linguistic knowledge works in substitution. Here we only present several
examples in Table.1.
Combining these two method of error generation,
we are able to generate 16 types grammatical
errors out
7
of 28 specified by CoNLL-2014 Shared Task (Ng et al.
[2014]).
1
Details are described by Algorithm 1,
which
formalizes the construction of substitution set, and Algorithm 2, which formalizes the process of error-generation
with linguistic knowledge.
4
Experiments
4.1
Settings
4.1.1
Data
We used data mainly from three sources (Table 2):
•
ACL Anthology
2
(ACL): training set.
•
AESW Shared Task Dataset (AESW) (Daudaravicius et al. [2016]) : development and test sets.
•
CCL Anthology
3
(CCL): development and test sets.
Set
# Token
Pct.
Vocab.
# Sent.
AESW
dev
24.4K
6.0%
4.1K
1.0K
test
24.7K
5.9%
4.1K
1.0K
CCL
dev
2.6K
5.5%
892
125
test
2.8K
5.2%
934
126
ACL
train
60.4M
4.9%
166.5K
2.9M
Table 2: Statistics of datasets used in the experiment. “Pct.” stands for percentage of tokens that are marked incor-
rect.
For training set, we used sentences from papers that appear in ACL Anthology. We crawled all papers up to year
2015, and then select sentences that end with a period, with a length of longer than 5 but no longer than 50, which
may contain several clauses separated by commas, colons or semicolons. Formulae and references are excluded,
numbers are substituted with a special
hnumi
token, and parentheses are removed together with the contents in
between. We limit the vocabulary to tokens with at least a word-frequency of 2 to eliminate most spelling errors,
and replaced all OOVs with a special
hunki
token.
To corroborate that the model trained by us actually works with realistic grammatical error, we used two human
annotated dataset as our development and test set.
The first one is the test set of AESW 2016 Shared Task, but we only used a portion of the erroneous sentences
from paragraphs with the attribute of “domain=Computer Science”; we converted the data format by preserving all
words between ‘
hdelih/deli
’ and marking them as incorrect, while removing those between ‘
hinsih/insi
’.
1
The error types can be generated are: Vt,
Vm,
Vform,
SVA,
ArtOrDet,
Nn,
Npos,
Pform,
Pref,
Prep,
Wci,
Wform,
Spar,
Trans,
Mec,
Others. Most of remaining error types we are unable to generate are either semantic errors (Smod, Rloc-, UM), or style problems (Wa, Wtone,
Cit), or sentence level problems (Srun, Sfrag, WOinc, WOadv).
2
http://www.aclweb.org/anthology/
3
http://www.cips-cl.org/anthology
8
For example, if the original annotated sentence is
More discussions
hdeli
about
h/delihinsi
on
h/insi
these issues will be provided in the remainder of the mono-
graph.
We convert it into the form of:
More discussions about these issues will be provided in the remainder of the monograph.
The second human annotated dataset is some erroneous sentences from papers in CCL Anthology annotated
by us, which contains grammatical errors since most of them are written by Chinese.
4.1.2
Baselines
To the best of our knowledge, word-level grammatical error detection task has never been researched before. Thus
we use the two methods described in 2.2 and 2.3. We compared our method to two baselines, both of which are
trained on the ACL training set.
•
Support Vector Machine (SVM).
•
Convolutional Network (Conv).
SVM takes into consideration the context
in a fixed window of size 5 around the current
word,
and gives
prediction of whether the current word is grammatically correct in the sentence. We first trained an
n
-gram model
with KenLM (Heafield [2011]) on the whole training set without artificial errors,
with
n
up to 3.
We then use
n
-gram scores as the input features into the SVM. In our experiment we used the open-source tool LibLinear (Fan
et al. [2008]).
In Conv, we use word-embeddings pre-trained using word2vec model in gensim (
ˇ
Reh
˚
u
ˇ
rek and Sojka [2010]),
the dimensionality of which we set to 50 empirically. A temporal convolution is performed over a window of fixed
size 3. The kernel width is set to equal to the size of fixed window. This model is implemented using Torch7.
4
4.1.3
BiLSTM with Intra-attention
Our model is implemented using Tensorflow.
5
We used cross-entropy as our loss function to optimize. We perform
gradient clipping by global norm (Pascanu, Mikolov, and Bengio [2013]) with the function provided in Tensorflow.
The dimention of word-embedding and hidden state are set to 150, as a trade-off between performance and training
time. The word-embedding matrix is initialized with random uniform distribution within range of
±0.05
.
4.2
Results and Discussion
Tables 3 and 4 presents the results of experiments of two baselines (SVM and T-Conv) and our model (BiLSTM),
using uniform random errors (uni.) or errors counterfeited with linguistic knowledge (ling.). From the two tables we
can see that our model outperformed the two baselines on both human-annotated datasets (AESW and CCL). The
F
0.5
score might seem low, but they are actually good results since these models are trained without supervision.
4
http://torch.ch/
5
https://www.tensorflow.org/
9
Method
Noise
Precision
Recall
F
0.5
SVM
uni.
13.53
6.27
10.99
ling.
12.51
7.15
10.88
Conv
uni.
6.25
50.10
7.57
ling.
18.13
4.46
11.24
BiLSTM
uni.
17.16
5.39
11.95
ling.
18.71
7.48
14.40
Table 3: Performance on the AESW test set measured by
F
0.5
(%)
.
Method
Noise
Precision
Recall
F
0.5
SVM
uni.
7.40
1.34
3.89
ling.
6.25
1.34
3.61
Conv
uni.
5.66
57.43
6.91
ling.
6.66
0.67
2.4
BiLSTM
uni.
16.00
2.68
8.03
ling.
21.05
8.05
15.91
Table 4: Performance on the CCL test set measured by
F
0.5
(%)
.
4.2.1
Effect of Error Types
If we focus on the task of detecting a limited number of error types (Verb form, Noun Number, Preposition misuse,
Article misuse),
the model would show better performance on CCL test set,
but weaker or only comparable to
AESW test set.
This is probably because in the annotating phase of CCL test set,
we focused heavily on these
common types of errors and some other types of errors are neglected. The results are shown in Tables 5 and 6.
Error Types
Attention
Precision
Recall
F
0.5
All
w/o
14.84
6.61
11.88
w/
18.71
7.48
14.40
Limited
w/o
19.87
4.25
11.45
w/
18.48
6.27
13.31
Table 5: Comparison on the AESW test set.
4.2.2
Effect of Attention
To verify our intra-attention help improve model performance, we removed the attention and performed the same
experiment. Comparison of models with and without attention is shown in Tables 5 and 6.
10
Error Types
Attention
Precision
Recall
F
0.5
All
w/o
23.40
7.38
16.32
w/
21.05
8.05
15.91
Limited
w/o
26.00
8.72
18.62
w/
27.90
16.10
24.34
Table 6: Comparison on the CCL test set.
Though the intra-attention mechanism worked, but in some cases it may fail. We believe that a more sophis-
ticated way of error generation is needed, because currently only those positions where substitution happens have
a chance to be labeled incorrect (“on-site-error” paradigms). But for the model to learn grammatical relations by
attention mechanism, we need massive paradigms where substitution cause another position to be labeled incorrect
(“off-site-error” paradigms). For example, in the sentence
An ugly bird was observed by the man yesterday .
If we substitute ugly with beautiful, our system will automatically annotate beautiful as incorrect (on-site-error)
An beautiful bird was observed by the man yesterday .
but our model will never know why it is incorrect. What we need instead are off-site-errors:
An beautiful bird was observed by the man yesterday .
so that the model knows beautiful is ok with ‘A’ but not with ‘An’. Unfortunately our method does not provide
such a mechanism to massively produce “off-site-error” paradigms, therefore our model have to rely on very few
coincidentally generated “off-site-error” paradigms which are too sparse.
Our current method also introduced some substitutions which should not be counted as errors. For example, if
yesterday is substituted by today:
An ugly bird was observed by the man today .
‘today’ is annotated as incorrect under our method, while it does not actually constitute grammatical error, which
therefore hurt model performance to some degree.
4.2.3
Examples
Our model
is found to perform well
in some cases,
while failing to identify others (Table 7)
6
.
It
works well
with collocations,
as seen in Ex.1.
It also works well with morphological problems,
as Ex.2 shows.
However it
is incapable of detecting errors of genre as in Ex.3. In Ex.4, it mistook as incorrect words out of domain of the
training data. It is apparent in Ex.5 that our model is aware of the missing are between polarities and opposite,
6
The table contains only a partial list of error type our model detected. Since we only detect errors without inferring their types, we are
unable to provide the full list of error types our model is able to detect.
11
but it reports error at a different position. There are other error types our model did not handle well with, such as
redundant determiners as in Ex.6.
Error Type
Example
Collocation
(Ex.1) In additions , we present an in-depth analysis that provides valuable insight into the
characteristics of alternative solutions.
Morphology
(Ex.2) In our work, lexical level features include the two entities, their NER tags, and the
neighbor tokens of these two entities.
Genre
(Ex.3) For the purpose of this study, we focus on one of our live broadcast, Premier Wen
Talks Online with Citizens on Feb 28, 2009.
Domain
(Ex.4) Note that , the communication cost of the PAROS layer is constant and dependent on
the network size and the gossiping period.
Wrong Position
(Ex.5) In summary, filtering the sentences whose polarities opposite to the overall orienta-
tion is significant for constructing a high quality training set.
Other
(Ex.6) Compared with other methods,
the our heterogeneous graph method improves the
results significantly.
Table 7: Example model predictions. Incorrect words are in bold face, and errors detected by our model are high-
lighted by underlines.
5
Related Work
5.1
Grammatical Error Detection and Correction
Several shared tasks on grammatical error detection or correction have been carried out in recent years, including
HOO-2011 (Dale and Kilgarriff [2011]), HOO-2012 (Dale, Anisimoff, and Narroway [2012]) , CoNLL-2013 (Ng
et al. [2013]), and CoNLL-2014 (Ng et al. [2014]). These four shared tasks all focused on grammatical error cor-
rection of English written by non-native speakers. The AESW shared task (Daudaravicius et al. [2016]) proposed
to evaluate scientific writing automatically based on sentence-level error identification.
Different from these shared tasks, we focus on word-level grammatical error detection, which is a pilot step
towards unsupervised approach to error correction.
To address the issue of grammatical error, researchers explored and utilized various methods. For example clas-
sification method was used by the top ranking team (Rozovskaya et al. [2013]) in CoNLL-2013 shared task. The top
ranking team (Felice et al. [2014]) of CoNLL-2014 shared task incorporated in their system a Statistical Machine
Translation (SMT) component, which translates erroneous English into correct English. With the development of
Neural Machine Translation (NMT) and attention mechanism (Bahdanau, Cho, and Bengio [2014]), the top team
(Schmaltz et al. [2016]) of AESW shared task adopted the NMT approach to grammatical error correction.
In comparison, we adopted a typical architecture of bi-directional LSTM (Hochreiter and Schmidhuber [1997])
on the encoder side (Cho et al. [2014]), but replace the decoder with a classifier. Since error types are not given in
unsupervised training, our classifier does not infer error types but only make binary prediction.
12
5.2
Error Generation
To obtain enough training data, various approaches have been employed to generate artificial error. Markov logic
network was used for statistical
grammar error simulation (Lee and Lee [2009]).
An automatic tool
for error
generation was developed (Foster and Andersen [2009]), which take as input a corpus and error generation rules.
Error inflation was used in UI system (Rozovskaya, Sammons, and Roth [2012]) in HOO-2012 shared task, and
similar method was performed on Japanese (Imamura et al. [2012]). To enlarge the size of training set, artificial
errors were injected into the corpus by Yuan and Felice in CoNLL-2013 shared task (Yuan and Felice [2013]).
Later they further researched the probabilistic manner of artificial
error generation with linguistic information
(Felice and Yuan [2014]).
Different from (Foster and Andersen [2009]), we build substitution set automatically from un-annotated corpus
based on POS tag or lemma,
while their tools require a set
of rules to work.
To compare with (Rozovskaya,
Sammons, and Roth [2012]; Yuan and Felice [2013]; Felice and Yuan [2014]), their methods of error generation
are based on annotated corpus, while we used only un-annotated error-free texts without any supervision.
5.3
RNNs and LSTM Units
Recurrent Neural Network (RNN) with Long Short-term Memory (LSTM) or Gated Recurrent Unit (GRU) has
shown a mighty capability to encode informations over long sequences (Cho et al. [2014]). The attention mech-
anism has enabled a Bi-directional RNN with GRU to achieve even better performance in machine translation
(Bahdanau, Cho, and Bengio [2014]) by allowing the decoder to explicitly make use of the memory of encoder.
Upon the emergence of attention mechanisms, it has been applied to many NLP topics other than machine transla-
tion. Grammatical error correction is of no exception. Schmaltz et al. used a uni-directional LSTM network with
attention mechanism and achieved the best performance in the AESW shared task (Schmaltz et al. [2016]).
Different from them, we do not need to generate target sentence because we are not doing correction. Therefore
we replaced the decoder with a binary classifier,
which take into consideration the information from BiLSTM
encoder.
6
Conclusion and Future Work
In our work, we have explored unsupervised word-level grammatical error detection using only un-annotated cor-
pus as training data. We showed that it is a viable way for machines to learn grammatical relations and to predict
grammatical errors. This inspires us to further extend unsupervised approach to grammatical error correction. In
the future, we plan to investigate novel methods for generating artificial errors to enable our model to learn better
intra-sentence attention.
References
Bahdanau, D.; Cho, K.; and Bengio, Y. 2014. Neural machine translation by jointly learning to align and translate.
CoRR abs/1409.0473.
Boser, B. E.; Guyon, I.; and Vapnik, V.
1992.
A training algorithm for optimal margin classifiers.
In COLT.
Cho,
K.; van Merrienboer,
B.; aglar G
¨
ulehre; Bahdanau,
D.; Bougares,
F.; Schwenk,
H.; and Bengio,
Y.
2014.
Learning phrase representations using rnn encoder-decoder for statistical machine translation.
In EMNLP.
13
Collobert, R., and Weston, J.
2008.
A unified architecture for natural language processing: deep neural networks
with multitask learning.
In ICML.
Cortes, C., and Vapnik, V.
1995.
Support-vector networks.
Machine Learning 20:273–297.
Dahlmeier, D., and Ng, H. T.
2012.
A beam-search decoder for grammatical error correction.
In EMNLP-CoNLL.
Dahlmeier,
D.; Ng,
H.
T.; and Wu,
S.
M.
2013.
Building a large annotated corpus of learner english: The nus
corpus of learner english.
Dale, R., and Kilgarriff, A.
2011.
Helping our own: The hoo 2011 pilot shared task.
In In Proc. of ENLG.
Dale,
R.; Anisimoff,
I.; and Narroway,
G.
2012.
Hoo 2012: A report on the preposition and determiner error
correction shared task.
Daudaravicius, V.; Banchs, R. E.; Volodina, E.; and Napoles, C.
2016.
A report on the automatic evaluation of
scientific writing shared task.
In Proceedings of the 11th Workshop on Innovative Use of NLP for Building
Educational Applications, 53–62.
San Diego, CA: Association for Computational Linguistics.
Fan, R.-E.; Chang, K.-W.; Hsieh,
C.-J.; Wang, X.-R.; and Lin, C.-J.
2008.
Liblinear: A library for large linear
classification.
Journal of Machine Learning Research 9:1871–1874.
Felice, M., and Yuan, Z.
2014.
Generating artificial errors for grammatical error correction.
In EACL.
Felice, M.; Yuan, Z.; Andersen, O. E.; Yannakoudakis, H.; and Kochmar, E.
2014.
Grammatical error correction
using hybrid systems and type filtering.
In CONLL.
Ford, H.
2015.
Automated evaluation of scientific writing: Aesw shared task proposal.
Foster, J., and Andersen, O. E.
2009.
Generrate: Generating errors for use in grammatical error detection.
Heafield, K.
2011.
KenLM: faster and smaller language model queries.
In Proceedings of the EMNLP 2011 Sixth
Workshop on Statistical Machine Translation, 187–197.
Hochreiter, S., and Schmidhuber, J.
1997.
Long short-term memory.
Neural Computation 9:1735–1780.
Imamura, K.; Saito, K.; Sadamitsu, K.; and Nishikawa, H.
2012.
Grammar error correction using pseudo-error
sentences and domain adaptation.
In ACL.
Lee, S., and Lee, G. G.
2009.
Realistic grammar error simulation using markov logic.
In ACL.
Ng, H. T.; Wu, S. M.; Wu, Y.; Hadiwinoto, C.; and Tetreault, J. R. 2013. The conll-2013 shared task on grammatical
error correction.
In CONLL.
Ng, H. T.; Wu, S. M.; Briscoe, T.; Hadiwinoto, C.; Susanto, R. H.; and Bryant, C.
2014.
The conll-2014 shared
task on grammatical error correction.
In CONLL.
Nicholls, D.
2003.
The cambridge learner corpus -error coding and analysis for lexicography and elt.
Pascanu, R.; Mikolov, T.; and Bengio, Y.
2013.
On the difficulty of training recurrent neural networks.
In ICML.
ˇ
Reh
˚
u
ˇ
rek, R., and Sojka, P.
2010.
Software Framework for Topic Modelling with Large Corpora.
In Proceedings
of the LREC 2010 Workshop on New Challenges for NLP Frameworks, 45–50.
Valletta, Malta: ELRA.
14
Rozovskaya, A., and Roth, D.
2010.
Generating confusion sets for context-sensitive error correction.
In EMNLP.
Rozovskaya, A.; Chang, K.-W.; Sammons, M.; and Roth, D.
2013.
The university of illinois system in the conll-
2013 shared task.
In CONLL.
Rozovskaya, A.; Sammons, M.; and Roth, D. 2012. The ui system in the hoo 2012 shared task on error correction.
Schmaltz, A.; Kim, Y.; Rush, A. M.; and Shieber, S. M.
2016.
Sentence-level grammatical error identification as
sequence-to-sequence correction.
CoRR abs/1604.04677.
Sukhbaatar, S.; Szlam, A.; Weston, J.; and Fergus, R.
2015.
End-to-end memory networks.
In NIPS.
Yuan, Z., and Felice, M.
2013.
Constrained grammatical error correction using statistical machine translation.
In
CONLL.
15
