Kmer-Based Sequence Representations for
Fast Retrieval and Comparison
A THESIS SUBMITTED TO
FACULTY OF SCIENCE AND ENGINEERING
OF QUEENSLAND UNIVERSITY OF TECHNOLOGY
IN FULFILMENT OF THE REQUIREMENTS
FOR THE DEGREE OF MASTER OF INFORMATION TECHNOLOGY
(RESEARCH)
ZUTAO WU
Faculty of Science and Engineering
Queensland University of Technology
2017
Kmer-Based Sequence Representations
for Fast Retrieval and Comparison
Zutao Wu
Zutao.Wu@hdr.qut.edu.au
Principal Supervisor:
A/Professor Dr Jim Hogan (j.hogan@qut.edu.au)
Associate Supervisor:
Dr Wayne Kelly (w.kelly@qut.edu.au)
Faculty of Science and Engineering
Queensland University of Technology
Statement of Original Authorship
The work contained in this thesis has not been previously submitted to meet
requirements for an award at this or any other higher education institution.
To
the best of my knowledge and belief, the thesis contains no material previously
published or written by another person except where due reference is made.
Signature:
Date:
QUT Verified Signature
Abstract
Next Generation Sequencing (NGS) technologies have led to an explosion in
genetic and genomic datasets.
This now poses a significant challenge to existing
sequence processing and searching, and has resulted in a strong need for more
scalable gene sequence similarity determination.
This new requirement has also
initiated new approaches for sequence processing, including the adaptation of
methods from other domains, such as information retrieval and deep learning.
Sequence similarity measurement is a fundamental problem in bioinformatics.
At present,
such processes are commonly conducted using alignment-based
similarity determination tools such as BLAST and Clustal.
Alignment-based
approaches have produced excellent results when sequences can be reliably
aligned.
However,
such methods may not adapt well
when the sequences are
structurally divergent, and they do not scale well when confronted with large-
scale sequence data.
The advent of NGS has resulted in the generation of a
huge amount of sequencing data,
which poses challenges for alignment-based
algorithms for assembly, annotation and comparative studies.
To solve this problem,
this work investigates an alignment-free method by
generating novel
representations for kmers and genes in multiple ways.
Here
we use the term representation to refer to short real
value vectors used to
represent kmers and genes when performing searches.
Sequence similarity can
be measured by calculating the distance between paired representations in a
desirable timeframe.
This research utilises conventional
methods from information retrieval
and
adapts approaches such as locality-sensitive hashing (LSH) and TF-IDF meth-
ods to generate kmer and sequence representations.
To increase precision, we
applied machine learning approaches -
especially neural
networks -
to learn
the potential
relationship between kmers
and to generate improved repre-
sentations.
The approaches investigated in this work have been thoroughly
evaluated using four di↵erent sequence datasets (ALF-DNA,
ALF-PROT- S,
ALF-PROT and Swiss-Prot), described in detail in the text.
These experiments have revealed that representation methods are on average
10 to 15 times faster and more efficient than alignment approaches.
Moreover,
in the sequence comparison tasks, representations learnt from neural networks
have shown mean average precision comparable to the alignment programs
Blast-fast and Clustal.
This work begins with the theory and extends to the
specific software development tasks required for neural
network learning of
kmer and gene representations,
and for the evaluation of
performance.
The
thesis concludes with a summary of these contributions, and some preliminary
explorations of future work based on these approaches.
Keywords Sequence alignment,
Searching,
Information retrieval,
Locality-
sensitive hashing,
TF-IDF,
Random Indexing,
Distance measurement,
Kmer
representations, Neural networks, Autoencoder neural network, Semantic neu-
ral network, Machine learning, Deep learning, Data science, Bioinformatics.
Acknowledgement
I would like to express my utmost appreciation to my supervisor,
Associate
Professor Jim Hogan, for his patience, motivation and inspiration throughout
the course of my masters degree.
I would like to extend my gratitude to my
associate supervisor, Dr Wayne Kelly, for providing me with his guidance dur-
ing my research period, and specific and detailed comments on my thesis draft.
This work could not have been conducted without their continual advice and
reassurance.
I would like to thank Dr Guido Zuccon,
Lawrence Buckingham
and Dr Timothy Chappell for providing lots of advice and suggestions for this
work.
Finally, it is necessary to acknowledge QUT for its support during my masters
degree.
During this research,
I attended several
bioinformatics seminars and
symposiums, as well as other tutorial classes.
Not only have these experiences
expanded my knowledge in this particular field,
but they have also improved
overall logic, precision and scientific attitude in other aspects of my life.
Contents
Contents
i
List of Figures
iv
List of Tables
ix
1
Introduction
1
1.1
Introduction .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1.1.1
Main Research Problem .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
1.1.2
Main Research Contributions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
4
1.1.3
Thesis Overview
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7
1.2
Background .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
1.2.1
DNA, Gene and Genome .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
1.2.2
Gene and Genome Sequencing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
10
1.2.3
Next Generation Sequencing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11
1.3
Sequence Alignment
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
1.3.1
Sequence Alignment Approaches .
.
.
.
.
.
.
.
.
.
.
.
.
.
15
1.3.2
Sequence Alignment Applications
.
.
.
.
.
.
.
.
.
.
.
.
.
17
1.4
Sequence Similarity Measurement
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
1.4.1
Research Data Preparation .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
23
1.4.2
Precision and Recall
Evaluation for Sequence Retrieval
Experiments .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31
i
1.4.3
Sequence Retrieval Experiment using Blast and Clustal
.
32
1.5
Discussion and Conclusion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
2
Representation Methods for Sequence Retrieval
38
2.1
Sequence Alignment-free Method
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
38
2.1.1
Kmers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39
2.2
Representations in Information Retrieval
.
.
.
.
.
.
.
.
.
.
.
.
.
41
2.3
Representations for Kmers and Sequences
.
.
.
.
.
.
.
.
.
.
.
.
42
2.3.1
Distance and Similarity Measurement .
.
.
.
.
.
.
.
.
.
.
44
2.4
Random Kmers and Sequences Representations
.
.
.
.
.
.
.
.
.
45
2.4.1
Sequence Retrieval Experiment
.
.
.
.
.
.
.
.
.
.
.
.
.
.
45
2.5
Locality Sensitive Hashing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53
2.5.1
Reflective Random Indexing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53
2.5.2
Sequence Retrieval Experiment
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55
2.6
TF-IDF Representation .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
63
2.6.1
Swiss-Prot sequence retrieval experiment
.
.
.
.
.
.
.
.
.
67
2.7
Compare Representation Approach to Sequence Alignment Tools
69
2.7.1
ALF-DNA sequence retrieval .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
2.7.2
ALF-PROT-S Sequence Retrieval
.
.
.
.
.
.
.
.
.
.
.
.
.
71
2.7.3
ALF-PROT Sequence Retrieval
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
2.7.4
Swiss-Prot sequence retrieval .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74
2.7.5
Efficiency and Speed
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75
2.8
Discussion and Conclusion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
77
3
Neural
Networks for Learning and Improving Kmer Repre-
sentations
79
3.1
Machine Learning .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79
3.1.1
Neural Network .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
82
3.1.2
Deep Learning .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
84
3.2
Using Neural Networks to Learn Kmer Representations
.
.
.
.
.
85
3.2.1
Autoencoder Neural Network
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
85
ii
3.2.2
Learn Kmer Representation Using Autoencoder Neural
Network .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
87
3.2.3
Neural Probabilistic Language Model
.
.
.
.
.
.
.
.
.
.
.
92
3.2.4
Learn Kmer Representations using Neural Network
.
.
.
95
3.3
Discussion and Conclusion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 115
4
Optimisation
118
4.1
Improve Gene Searching Precision Using Gene Partitions
.
.
.
. 119
4.1.1
Gene Searching Experiments Using Partitioning Approach119
4.2
Discussion and Conclusion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 122
5
Future work and Conclusions
123
5.1
Future Work .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 123
5.1.1
Accelerate Neural Network Model Using Hierarchical Soft-
max
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 123
5.1.2
Signatures - Binary Representations .
.
.
.
.
.
.
.
.
.
.
. 126
5.1.3
Sequence Family Classification .
.
.
.
.
.
.
.
.
.
.
.
.
.
. 129
5.1.4
Parallel Computing .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 131
5.2
Conclusions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 133
5.2.1
Summary of the Research
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 133
5.2.2
Conclusion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 135
6
Appendices
137
6.1
Main Programs Implementation .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 137
6.2
Third Party Programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 140
Bibliography
142
iii
List of Figures
1.1
Increasing trend of total sequence data in Genebank.
.
.
.
.
.
.
2
1.2
Double helix structure of the DNA. The double helix is built up
by linearly linked nucleotides connected by a sugar-phosphate
backbone.
Hydrogen-bonds form only between A and T and
between G and C. From US. National Library of Medicine
.
.
.
9
1.3
ALF-DNA sequences retrieval experiment using Blastn, MegaBlast
and Clustal-Omega. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33
1.4
ALF-Prot-S sequences retrieval experiment using Blastp, Bastp-
fast and Clustal-Omega.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
34
1.5
ALF-Prot sequences retrieval
experiment using Blastp,
Bastp-
fast and Clustal-Omega.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35
1.6
Swiss-Prot sequences retrieval experiment using Blastp, Bastp-
fast and Clustal-Omega.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
2.1
5mers in a nucleic acid sequence (DNA)
.
.
.
.
.
.
.
.
.
.
.
.
.
40
2.2
A general approach of generating representations for sequences.
43
2.3
ALF-DNA Sequence retrieval precision and recall - Random rep-
resentations.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46
2.4
ALF-DNA Sequence retrieval precision and recall - Random rep-
resentations for di↵erent length of kmers.
.
.
.
.
.
.
.
.
.
.
.
.
.
47
2.5
ALF-PROT-S sequence retrieval precision and recall - Random
representations.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
49
iv
2.6
ALF-PROT-S sequence retrieval precision and recall - Random
representations for di↵erent length of kmers.
.
.
.
.
.
.
.
.
.
.
.
50
2.7
ALF-PROT sequence retrieval
precision and recall
-
Random
representations.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
2.8
ALF-PROT sequence retrieval
precision and recall
-
Random
representations for di↵erent length of kmer.
.
.
.
.
.
.
.
.
.
.
.
52
2.9
ALF-DNA sequence retrieval
precision and recall.
Reflective
Random Indexing Representations .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
56
2.10 ALF-DNA sequence retrieval
precision and recall.
Reflective
Random Indexing Representations for di↵erent length of kmers.
56
2.11 ALF-PROT-S sequence retrieval precision and recall - Reflective
Random Indexing Representations .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58
2.12 ALF-PROT-S Sequence retrieval
precision and recall
- Reflec-
tive Random Indexing Representations for di↵erent length of
kmers.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
58
2.13 ALF-PROT Sequence retrieval precision and recall - Reflective
Random Indexing Representations .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
60
2.14 ALF-PROT Sequence retrieval precision and recall - Reflective
Random Indexing Representations for di↵erent length of kmers.
60
2.15 Swiss-Prot Sequence retrieval
precision and recall
- Reflective
Random Indexing Representations for di↵erent length of kmers.
62
2.16 A log-log scale plot of the rank versus frequency for the first 10
million words in Wikipedias in 30 languages [49].
.
.
.
.
.
.
.
.
65
2.17 A plot of frequency versus rank for all kmers (3mers) in Swiss-
Prot.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
66
2.18 Swiss-Prot sequence retrieval precision and recall - TF-IDF rep-
resentations.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
68
2.19 ALF-DNA sequence retrieval
precision and recall.
Comparing
locality-sensitive hashing methods (Reflective Random Index-
ing) to Blast and Clustal-Omega .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
70
v
2.20 ALF-PROT-S sequence retrieval precision and recall.
Compar-
ing locality-sensitive hashing methods (Reflective Random In-
dexing) to Blast and Clustal-Omega .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
71
2.21 ALF-PROT Sequence retrieval precision and recall.
Comparing
locality-sensitive hashing methods (Reflective Random Index-
ing) to Blast and Clustal-Omega .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73
2.22 Swiss-Prot Sequence retrieval
precision and recall.
Compares
locality-sensitive hashing methods (reflective Random Indexing)
and TF-IDF to Clustal and Blast
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
74
2.23 Execution time of
di↵erent approaches in sequence searching
tasks.
Comparison of representation approach to alignment pro-
grams.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
76
3.1
A schematic diagram of machine learning.
An overview of ma-
chine learning processes for a given task.
.
.
.
.
.
.
.
.
.
.
.
.
.
80
3.2
A schematic diagram of a neural network.
[19]
.
.
.
.
.
.
.
.
.
.
83
3.3
Autoencoder neural network model
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
86
3.4
Autoencoder neural
network model
for experiment.
Examples
of learning representations for AAAAAA and AAAAAC.
.
.
.
.
89
3.5
ALF-DNA sequence retrieval
precision and recall.
Compare
kmer representations extracted from autoencoder neural
net-
work to other approaches in ALF-DNA sequence retrieval
ex-
periment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90
3.6
An illustration of
Word representation in 3-dimensional
space
[46].
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
93
3.7
The model architectures.
The Continuous-Bag-of-Words (CBOW)
architecture predicts the current word based on the context, and
the Skip-gram predicts surrounding words given the current word.
93
3.8
An example of neural network language model. .
.
.
.
.
.
.
.
.
.
94
vi
3.9
Neural network model for learning representations of kmers.
In-
put slide window size is 1.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
98
3.10 Neural network model for sequence
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
98
3.11 Neural network training loss rate
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 101
3.12 Representations of 3mers & 4mers are shown as clustered using
kmeans and projected into a 2-D space.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 102
3.13 ALF-DNA sequence retrieval
precision and recall.
Compares
kmer representations extracted from neural
network to other
approaches .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 104
3.14 ALF-DNA sequence retrieval precision and recall.
Compare dif-
ferent kmer representations extracted from neural network.
.
.
. 106
3.15 ALF-PROT-S sequence retrieval precision and recall.
Compares
SNN representation to other representation approaches.
.
.
.
.
. 107
3.16 ALF-PROT-S sequence retrieval precision and recall.
Compare
SNN representation with di↵erent lengths of kmer. .
.
.
.
.
.
.
. 109
3.17 ALF-PROT sequence retrieval
precision and recall.
Compares
SNN representation to other representation approaches.
.
.
.
.
. 110
3.18 ALF-PROT sequence retrieval
precision and recall.
Compare
SNN representation with di↵erent lengths of kmer. .
.
.
.
.
.
.
. 111
3.19 Swiss-Prot sequence retrieval
precision and recall.
Compares
SNN representation using di↵erent length of kmer. .
.
.
.
.
.
.
. 113
3.20 Swiss-Prot
sequence retrieval
precision and recall.
Compare
SNN representation using di↵erent length of kmer. .
.
.
.
.
.
.
. 114
4.1
Improve searching precision by dividing gene sequence into par-
titions.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 119
4.2
ALF-DNA sequence retrieval
precision and recall.
Using par-
tition method to improve precision of
representation method.
Divide every DNA sequence into 32 length of partitions with 16
length overlapped.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 120
vii
4.3
Swiss-Prot sequence retrieval
precision and recall.
Using par-
tition method to improve precision of
representation method.
Divide every protein sequence into partitions (length 32)
.
.
.
. 121
5.1
Neural network model.
Input layer and hidden layer .
.
.
.
.
.
. 124
5.2
Neural network model.
Output layer and hidden layer .
.
.
.
.
. 124
5.3
Hierarchical
softmax using binary tree.
The path from root to
each leaf represent each kmer.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 126
5.4
ALF-PROT-S sequence retrieval
precision and recall.
Using
binary representations (signatures) converted from real
valued
representations.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 127
5.5
ALF-Prot sequences family classification using SVM. Compare
sequences SNN representation to KCV and TF-IDF representa-
tion.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 130
5.6
Execution time (a) and corresponding speedup (b) of the three
di↵erent implementations performing 1,000 learning iterations
of a neural network. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 132
viii
List of Tables
1.1
Bioinformatics Research Fields .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
3
1.2
Bacteria genome base pairs and genes number
.
.
.
.
.
.
.
.
.
.
10
1.3
Massively parallel sequencing platform .
.
.
.
.
.
.
.
.
.
.
.
.
.
12
1.4
Insertion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
1.5
Deletion .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
1.6
Substitution .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
1.7
Sequence alignment algorithms comparison (N and M refer to
the length of two sequences)
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
16
1.8
An example of FASTA format
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19
1.9
Blast family programs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21
1.10 Details of DNA sequences dataset - ALF-DNA .
.
.
.
.
.
.
.
.
.
25
1.11 Details of Protein sequences dataset - ALF-PROT-S .
.
.
.
.
.
.
27
1.12 Details of protein sequences dataset - ALF-PROT .
.
.
.
.
.
.
.
29
1.13 Swiss-Prot.
A sample of annotated sequence
.
.
.
.
.
.
.
.
.
.
.
30
1.14 Swiss-Prot.
A sample of meta data
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30
1.15 Details of protein sequences dataset - Swiss-Prot .
.
.
.
.
.
.
.
.
31
1.16 MAP of Blastn, MegaBlast and Clustal in ALF-DNA sequences
retrieval experiment .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
33
1.17 MAP of Blast and Clustal in ALF-PROT-S sequences retrieval
experiment .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
34
ix
1.18 MAP of
Blast and Clustal
in ALF-PROT sequences retrieval
experiment .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35
1.19 MAP of Blast and Clustal in Swiss-Prot sequences retrieval ex-
periment .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
36
2.1
Distance function table.
Di↵erent representations fit di↵erent
distance function.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44
2.2
MAP of
Random Representations in ALF-DNA Sequence re-
trieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
46
2.3
MAP of
Random Representations in ALF-DNA Sequence re-
trieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
47
2.4
MAP of
Random Representations in ALF-PROT-S sequence
retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
49
2.5
MAP of
Random Representations in ALF-PROT-S sequence
retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
50
2.6
MAP of Random Representations in ALF-PROT sequence re-
trieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
2.7
MAP of Random Representations in ALF-PROT sequence re-
trieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
52
2.8
MAP of
random and locality-sensitive hashing (reflective ran-
dom indexing) representation approaches for ALF-DNA sequence
retrieval experiments.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
57
2.9
MAP of
random and locality-sensitive hashing (reflective ran-
dom indexing) representation approaches for ALF-PROT-S se-
quence retrieval experiments. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59
2.10 MAP of random and locality-sensitive hashing (random index-
ing) representation approaches for ALF-PROT sequence retrieval
experiments.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61
2.11 MAP of locality-sensitive hashing (random indexing) represen-
tation approaches for Swiss-Prot sequence retrieval experiments.
62
x
2.12 MAP of Swiss-prot sequence retrieval.
Compare di↵erent rep-
resentation methods with di↵erent length of kmer.
.
.
.
.
.
.
.
.
69
2.13 MAP of ALF-DNA sequence retrieval.
Compare representation
method to alignment approach.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
71
2.14 MAP of ALF-PROT-S sequence retrieval.
Compares represen-
tation method to alignment approach. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
2.15 MAP of ALF-PROT sequence retrieval.
Compares representa-
tion method to alignment approach.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73
2.16 MAP of Swiss-Prot sequence retrieval.
Compares representation
method to alignment approach.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75
3.1
ALF-DNA Dataset for autoencoder neural network training
.
.
88
3.2
Mean average precision of
representations learnt from autoen-
coder neural network.
Compare kmer representations extracted
from autoencoder neural network to other approaches in ALF-
DNA sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
90
3.3
Two similiar gene sequence.
A to K represent di↵erent kmers .
.
96
3.4
A DNA sequence divided into 6mers for training neural network.
97
3.5
ALF-DNA sequences dataset for training neural network
.
.
.
. 104
3.6
MAP of
representations learnt from a neural
network.
Com-
pares kmer representations extracted from the neural
network
to other approaches in ALF-DNA sequence retrieval experiment. 105
3.7
MAP of
representations learnt from a neural
network.
Com-
pares kmer (with di↵erent kmer length) representations extracted
from the neural network in ALF-DNA sequence retrieval exper-
iment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 106
3.8
ALF-PROT-S sequences dataset for neural network training
.
. 107
3.9
MAP of representations learnt from neural network.
Compares
kmer representations extracted from neural
network to other
approaches in ALF-PROT-S sequence retrieval experiment.
.
.
. 108
xi
3.10 MAP of representations learnt from neural
network.
Compare
kmer representations extracted from neural
network in ALF-
PROT-S sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 109
3.11 ALF-PROT sequences dataset for neural network training
.
.
. 110
3.12 MAP of representations learnt from neural network.
Compares
kmer representations extracted from neural
network to other
approaches in ALF-PROT sequence retrieval experiment.
.
.
.
. 111
3.13 MAP of representations learnt from neural
network.
Compare
kmer representations extracted from neural
network in ALF-
PROT sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 112
3.14 Swiss-Prot sequences dataset for neural network training
.
.
.
. 112
3.15 MAP of
representations learnt from a neural
network.
Com-
pares kmer representations extracted from the neural
network
in Swiss-Prot sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
. 114
3.16 MAP of
representations learnt from a neural
network.
Com-
pares kmer representations extracted from the neural
network
in Swiss-Prot sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
. 115
4.1
MAP of representations learnt from neural
network with opti-
misation in ALF-DNA sequence retrieval experiment.
.
.
.
.
.
. 120
4.2
MAP of representations learnt from neural
network with opti-
misation in Swiss-prot sequence retrieval experiment.
.
.
.
.
.
. 121
5.1
Number of
connections between hidden and output layer for
di↵erent kmer and di↵erent size of hidden layer
.
.
.
.
.
.
.
.
. 125
5.2
MAP of signatures converted from SNN representation in ALF-
PROT-S sequence retrieval experiment.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 128
5.3
Evaluation of Sequence Family Classification.
.
.
.
.
.
.
.
.
.
. 130
xii
List of Algorithms
1
Pseudo-code algorithm for generating random representations for
kmers and sequences .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
45
2
Reflective Random Indexing Represenations for Kmers
.
.
.
.
.
.
55
3
Generating TF-IDF Represenations for Kmers .
.
.
.
.
.
.
.
.
.
.
67
4
Stochastic Gradient Descent .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. 100
xiii
Chapter 1
Introduction
1.1
Introduction
Bioinformatics developed slowly in the 1960s, with an explosion of interest from
the 1990s.
By the early 1960s,
a growing collection of protein sequence data
allowed biologists to address more complicated problems and diseases.
The
first DNA sequences were gathered in the early 1970s using laborious methods
based on two-dimensional chromatography.
Knowledge of DNA sequences had
become indispensable for basic biological
research and in numerous applied
fields, such as medical diagnosis, biotechnology, forensic biology, virology and
biological systematics [15].
Due to advanced developments in the computer and data science fields,
to-
gether with the next-generation sequencing technologies developed in the last
decade, the size of our sequencing datasets has significantly increased.
As seen
in Figure 1.1,
currently the scale of
sequencing data outputted from the se-
quence machines is growing exponentially, and there is no sign of this slowing
down.
It is now clear that current research trends are changing to deal
with
the challenge of processing huge amounts of sequencing data.
1
Chapter 1.
Introduction
Figure 1.1:
Increasing trend of total sequence data in Genebank.
2
Chapter 1.
Introduction
Bioinformatics includes a wide range of methods across related fields, with the
primary goal being to increase the understanding of biological processes (Table
1.1).
Here, our focus is on sequence comparison.
Bioinformatics Research Fields
Genome annotation.
Sequence comparison.
Analysis of regulation.
Analysis of mutations in cancer.
Analysis of gene expression.
Table 1.1:
Bioinformatics Research Fields
1.1.1
Main Research Problem
Sequence similarity measurement is one of the most important tasks in bioin-
formatics.
With the help of results from sequence similarity analysis, scientists
are able to conduct the following fundamental research regarding genes:
• Identifying a species or finding homologous species.
• Locating known domains within the sequence of interest.
• Creating a phylogenetic tree using the results received through alignment
programs.
• Mapping annotations from one organism to another based on sequence
comparison.
Currently,
similarity analysis is conducted using alignment-based tools,
such
as Blast and Clustal.
These approaches and tools have contributed to great
achievements in sequence analysis and have underpinned the basis of biological
and genetic research.
However,
due to the development of
Next-generation
sequencing (NGS) technologies,
alignment-based approaches have begun to
3
Chapter 1.
Introduction
show their weaknesses when facing dramatically growing datasets.
Due to
this, the main objective of this research has been to investigate and develop a
new approach for sequence comparison.
Over the past few decades, rapid developments in genomic research, informa-
tion technologies and machine learning have also combined to produce new
research fields in knowledge discovery [92].
In modern search engines, in order
to locate results from huge amounts of data, custom representations of search-
able objects are often utilised to represent the documents or other searchable
objects in a query.
These representations or features are also the keys to de-
termining the quality and accuracy of learning results from machine learning
models.
Overall,
this research has been conducted to develop a new method to over-
come the shortcomings of
alignment programs in sequence comparison and
classification tasks.
Our focus is on the development of a novel representation
for the underlying content of the sequence.
1.1.2
Main Research Contributions
Here we will use the term representation to mean a short binary or real-valued
string or vector used to represent documents or other searchable objects in a
query.
Modern search engines utilise representations to accelerate searching
process.
This work investigated di↵erent approaches to create representations
for gene sequences to measure sequence similarity and classify sequences.
Sev-
eral contributions have been made in this research:
Methods of creating the representation for gene sequence
Several
representation methods have been successfully used in the current
searching framework and adapted to the methods used in genetic sequence
searching tasks.
Results
have shown that
computational
efficiency is
the
4
Chapter 1.
Introduction
biggest advantage of
representation methods.
They are more than 10 times
faster than commonly used alignment programs in sequence comparison for
the problems considered.
Machine learning in sequence representation creation
To improve the precision of
representation method in sequence comparison
problems, this work utilised machine learning techniques to learn an improved
representation for kmers and sequences.
Using the representations learnt from
a neural
network model,
precision of
sequence comparison results was much
higher than the common representation methods from information retrieval.
Evaluation of representation method
To evaluate performance, this work used four di↵erent datasets, both synthetic
and real.
ALF-DNA, ALF-PROT-S (ALF-PROT-Standard) and ALF-PROT
are artificial
datasets generated from the Alfsim program [22].
Swiss-Prot is
a real-world protein sequence dataset with manually labelled annotation and
family information.
By conducting di↵erent searching experiments on these
di↵erent datasets, with the help of a searching and retrieval evaluation method
(precision and recall), this work has exhaustively discussed and demonstrated
the feasibility of our representation methods in sequence searching and com-
parison problems.
This work has also demonstrated that in the real-world
sequence (Swiss-Prot) searching and comparison,
representations learnt from
a neural network have shown better average precision than sequence alignment
programs Blastp-fast and Clustal, with results approaching those of Blastp.
Program development
In this research, several research programs and scripts for sequence searching
and classification were developed to support the current outcome and future
study of this work.
These programs included multithread neural network pro-
grams to learn representations from large sequence datasets,
and a sequence
5
Chapter 1.
Introduction
comparison program based on representation methods.
The software developed in this project and the datasets used are available on
GitHub at https://github.com/vvilp/GenomeKit.
6
Chapter 1.
Introduction
1.1.3
Thesis Overview
This section outlines the chapters in the thesis.
The remainder of the study is
shown as follows:
Chapter 1
Chapter 1 introduces the research question, its main goals and the motivation
for it.
This chapter also provides the background of molecular computational
biology and reviews the development of NGS technologies.
The advantages and
disadvantages of alignment methods and programs are also discussed.
More-
over, the experimental datasets used in this research are introduced.
Starting
with sequence comparison experiments using sequence alignment programs,
this chapter leads to the following topics and experimental
methods of
the
research.
Chapter 2
Chapter 2 introduces the core idea of using novel
representations of genes to
measure their similarity.
It reviews several methods, such as locality-sensitive
hashing (LSH) and TF-IDF for creating representations of searchable objects
and adapting them to a bioinformatics sequence dataset.
The experiments in
this chapter demonstrate that compared to conventional alignment approaches,
the representation method in sequence similarity comparison o↵ers significant
advantages in terms of processing efficiency and speed.
Chapter 3
Chapter 3 discusses the potential
ways of utilising machine learning to learn
representations of
kmers and genes.
This chapter starts with a neural
net-
work model
(an autoencoder neural
network) that is commonly used in deep
learning.
Experiments show that shorter representations generated from au-
7
Chapter 1.
Introduction
toencoder neural
networks can achieve higher precision than the approaches
described in Chapter 2.
Furthermore,
this chapter shows a neural
network
model
mainly designed for sequence datasets for learning kmer and sequence
representations.
Kmer and sequence representations learnt from the neural
network model
used in sequence searching and comparison achieves a better
result than all other approaches mentioned in this work.
Chapter 4
Chapter 4 describes the optimisation strategies and approaches used in this
research to speed up neural network training processing and to improve gene
sequence comparison precision.
Chapter 5
This chapter highlights the main contributions and conclusions from this study,
and discusses potential directions for future work related to this research.
Appendices
Appendices list the main programs and scripts created in the course of
this
research,
along with links to the source code and datasets.
Third party tools
supporting this work are also listed in this section.
8
Chapter 1.
Introduction
1.2
Background
“The mathematical,
statistical
and computing methods that
aim to solve
biological
problems using DNA and amino acid sequences and related in-
formation - Bioinformatics” (Fredj Tekaia, Institut Pasteur)
1.2.1
DNA, Gene and Genome
DNA is a molecular carrier that maintains all organisms genetic information.
DNA is a nucleic acid made up of
constituent nucleotides.
Each nucleotide
has three components:
a 5-carbon sugar, a phosphate group and a nitrogenous
base, and is usually denoted by a single character:
Cytosine (C), guanine (G),
adenine (A),
or thymine (T) [90].
A gene is a region of
DNA that encodes
a protein or a functional
RNA.
Most biological
traits are under the influence
of
di↵erent genes,
as well
as the gene-environment interactions,
which are
responsible for evolution and functioning of all living organisms [48].
Figure 1.2:
Double helix structure of
the DNA.
The double helix is built
up by linearly linked nucleotides connected by a sugar-phosphate backbone.
Hydrogen-bonds form only between A and T and between G and C. From US.
National Library of Medicine
9
Chapter 1.
Introduction
A genome can be viewed as a complete set of
DNA in an organism which
includes all
the genes.
To maintain and build the organism,
each genome
contains all
the information it needs [51].
Both the number of genes and the
number of base pairs vary enormously in di↵erent species.
For example a bacteria genome consists of around 2 ⇥ 10
6
to 5 ⇥ 10
6
base pairs.
Bacteria Genome
Bacteria Type
Base Pairs
Genes
E. coli K-12
4,639,221
4,377
E. coli O157:H7
5,441,123
5,416
S. aureus COL
2,813,862
2,615
S. aureus ED133
2,832,478
2,653
Table 1.2:
Bacteria genome base pairs and genes number
In contrast, the whole genome of human DNA is composed of about 3 billion
base pairs, of which more than 99 per cent are the same in all humans.
These
genes and genomes are contained in basically all cells containing a nucleus [16].
1.2.2
Gene and Genome Sequencing
In the 1970s, the sequencing of DNA molecules began with the development of
the Maxam-Gilbert method,
developed by Allan Maxam and Walter Gilbert.
This particular method is based on “nucleobase-specific partial chemical mod-
ification of DNA and subsequent cleavage of the DNA backbone at sites adja-
cent to the modified nucleotides” [39].
Historically,
the DNA sequencing approach most utilised in medical
and re-
search laboratories is derived from the Sanger method originally developed by
Frederick Sanger in 1975 [69].
Sanger sequencing is based on “the selective
incorporation of
chain-terminating dideoxynucleotides
by DNA polymerase
10
Chapter 1.
Introduction
during in vitro DNA replication” [70].
Until
nowadays,
the Sanger method
remains in wide use, especially for smaller-scale projects.
The Human Genome Project (HGP) was launched in 1990,
fostering rapid
advances in the analysis of sequencing data.
The HGP was completed in 2003,
at a cost of 3 billion US.
Almost all
of the actual
sequencing of the genome
was conducted at numerous universities and research centres throughout the
United States, the United Kingdom, France, Germany, Japan and China.
1.2.3
Next Generation Sequencing
Next generation sequencing (NGS) technologies emerged in the early 2000s
and have dramatically changed research in genomics.
The previous Sanger
sequencing technology required over 10 years to create the final human genome
draft.
In contrast, using recent NGS approaches, the entire human genome can
be sequenced in a single day [42].
Most importantly, the development of these
approaches has allowed rapid evolution of the fields of genomics and molecular
biology.
While maintaining relatively lower costs,
NGS technology provides
better qualitative and quantitative data on any type of nucleic acid in a given
organism [63].
Massively parallel sequencing
Massive parallel
sequencing or massively parallel
sequencing is any of
sev-
eral
high-throughput approaches that allow DNA to be sequenced extremely
rapidly.
At each step of massive parallel sequencing, more sophisticated DNA sequenc-
ing instruments, programs, and bioinformatics have provided more automation
and higher throughput.
Several
massively parallel
sequencing methods have
become available in the last couple of years,
allowing larger-scale production
11
Chapter 1.
Introduction
of genomic sequence, and the number of human genomes sequenced with such
instrumentation is now increasing rapidly.
These technologies use miniaturized
and parallelized platforms for sequencing of 1 million to 43 billion short reads
(50-400 bases each) per instrument run [82].
The cost of
sequencing an entire human genome has rapidly reduced,
now
nearing $1,000 per genome down from an estimated cost of
US $2.7 billion
in 2003 when the Human Genome Project published the first human genome
sequence.
This is fast approaching the point where,
economically,
genome
sequencing may become a routine part of pathology testing, preparing the way
for individually targeted, precise clinical patient management.
At present, there are four main sequencing technologies commercially available,
and several other promising technologies are in various stages of development
and implementation, as shown in table 1.3.
Massively parallel sequencing platform
Platform
Max
Read
length
(base
pairs)
Run
Times
(days)
Max Gb per
Run
Roche 454
400
0.42
0.40-0.60
Illumina MiSeq
600
0.17-2.7
15
Illumina HiSeq
300
0.3-11
1000
Life
Technologies
SOLiD4
35-50
4-7
35-50
Table 1.3:
Massively parallel sequencing platform
Compared to the traditional sequencing approaches, instead of generating long
reads from a sample,
massively parallel
sequencing methods provide shorter
reads (20 to 400 base pairs),
but millions of
reads.
Using new approaches,
sequencing can also be applied from single DNA molecules,
which are unlike
the previous sequencing methods that required DNA amplification [82].
Development of sequencing technologies has quickly reduced sequencing costs.
12
Chapter 1.
Introduction
It is predicted that in the future, sequencing costs will be a minor component of
the total project.
Data explosion will create new algorithmic challenges.
The
huge amount of data derived from massively parallel sequencing research might
take a long time to be interpreted and translated into meaningful
and useful
information.
Therefore,
it will
require bioinformatic and high-performance
computing support.
In addition,
the quality control
and standardisation of
the NGS experiments will be important issues to consider [63].
13
Chapter 1.
Introduction
1.3
Sequence Alignment
With the help of techniques such as NGS, either nucleic acids or amino acids
can be sequenced at a significant speed.
Hence,
a huge amount of biological
data and an increasing bulk of
sequences have to be analysed,
which is im-
possible without advanced data processing methods.
Sequence alignment (a
means of identifying DNA,
RNA or protein sequence region similarities) is a
critical procedure in bioinformatics and the core of current approaches [20].
In two similar gene sequences,
mismatches can be interpreted as insertion,
deletion and substitution, which are shown below:
Insertion
A A G T C C – G T T A G C
A A G T C C G G T T A G C
Table 1.4:
Insertion
Deletion
A A C C C C G T T T
A A C C C – G T T T
Table 1.5:
Deletion
Substitution
A G C T T C C G T A A
A G C A T C G G T A A
Table 1.6:
Substitution
Identifying both mismatches and similarities between gene sequences can help
scientists determine the structural or functional relationship between sequences.
Alignments of lengthy and highly variable mutations, or large amounts of se-
quences, are usually difficult and cannot be conducted by human e↵ort.
Many
algorithms and methods have been discovered to conduct high-quality sequence
alignments in two general types:
local alignments and global alignments.
14
Chapter 1.
Introduction
Conducting local
alignments involves matching the query with a portion of
the subject sequence.
In contrast, global alignment performs end-to-end align-
ment spanning the entire length of all
query sequences.
A variety of relevant
approaches have been applied to the sequence alignment problems,
such as
dynamic programming, heuristic algorithms and probabilistic methods.
1.3.1
Sequence Alignment Approaches
Local and global sequence alignment
Needleman-Wunsch was the first global alignment sequence method developed
in the early 1970s, based on dynamic programming.
The Needleman-Wunsch
algorithm was also an optimal
matching algorithm and a global
alignment
technique [53].
However,
in sequence analysis,
local
alignment may be more
useful identifying sequences containing similar regions or sequence motifs.
The
Smith-Waterman algorithm is a local
alignment method based on dynamic
programming, and is, therefore, more useful [74].
In information theory, the Levenshtein distance is an algorithm for measuring
the distance and di↵erence between two sequences (or two strings) [52].
The
Levenshtein distance is the minimum number of edits
1
between two sequences
(or strings), which may also be referred to as the edit distance [86].
The Hirschberg algorithm is another dynamic programming algorithm that
finds the optimal alignment between two sequences.
This approach can be seen
as the optimal implementation of Needleman-Wunsch,
which uses the Leven-
shtein algorithm to measure the sequences distance.
Due to this, the Hirschberg
algorithm decreases the space complexity from O(N M ) to O(min(N, M )) (N
and M refer to the length of two sequences) [29].
1
Edits refer to insertions, deletions or substitutions
15
Chapter 1.
Introduction
Pair-wise sequence alignment algorithms
Algorithm
Type
Time complexity
Space
complex-
ity
Needleman - Wunsch
Global
O(NM)
O(NM)
Smith - Waterman
Local
O(NM)
O(NM)
Hirschberg
Global
O(NM)
O(min(N, M))
Table 1.7:
Sequence alignment algorithms comparison (N and M refer to the
length of two sequences)
Table 1.7 compares the di↵erent algorithms in terms of their time complexity
and space complexity.
Alignment algorithms based on a dynamic programming
approach have the same idea,
which divide large and long sequences into a
series of short sequences.
Multiple sequence alignment (MSA)
In recent years, due to the explosion of sequence data from the NGS platform,
fast and accurate alignment programs are required in the research and pro-
duction environments.
MSA uses sequence alignment methods for sequence
sets containing more than two biological
sequence alignments [20].
In many
cases, the query sequences are supposed to descend from a common ancestor or
have an evolutionary relationship.
From MSA,
the phylogenetic relationship
can be inferred,
and homologous sequences can be discovered.
The dynamic
programming technique is a direct method for MSA to identify the globally
optimal
alignment solution.
The exact way of
computing an optimal
align-
ment between N sequences has a computational
complexity of
O(L
N
) for N
sequences of length L.
Most automatic MSA methods are based on the ‘pro-
gressive alignment’ heuristic, which aligns sequences in larger and larger sub-
alignments, following the branching order in a ‘guide tree’, with a complexity
of roughly O(N
3
L) in general [72].
16
Chapter 1.
Introduction
1.3.2
Sequence Alignment Applications
At present, there are hundreds of software applications for sequence alignment
and similarity measuring purposes.
To align sequences,
a standard process
is to utilise dynamic programming, which guarantees mathematically optimal
alignment.
All
alignment programs are derived from this idea.
Heuristic ap-
proaches regarding process speed are also often introduced to sequence align-
ment.
In this section, several of the main sequence alignment applications are
discussed[80].
FASTA
FASTA was developed in 1985,
and is a first generation sequence alignment
program designed for protein and DNA sequence similarity searching.
With
recent developments, it now also provides more advanced functions for evalu-
ating statistical significance [37].
The FASTA package provides di↵erent programs for di↵erent usage and con-
ditions,
including DNA to DNA,
protein to protein and specially translated
search algorithms for handling frameshift errors
2
, when comparing nucleotide
to protein sequence data.
The FASTA programs concentrate on sequence ac-
curate similarity statistics, so that sequence alignment can be inferred to have
occurred by chance, or the programs can be used to decide homology [57].
Methods
In general,
FASTA inputs
a given nucleotide or
amino acid sequence and
searches the sequence database using local sequence alignment to find matches.
In this process, FASTA also follows several heuristic methods, which contribute
2
A frameshift error (also called a framing mutation or a reading frame shift) is a
genetic mutation caused by indels (insertions or deletions) of a number of nucleotides
in a DNA sequence that is not divisible by three.
17
Chapter 1.
Introduction
to the execution speed.
FASTA uses four steps to calculate three scores that
characterise sequence similarity.
The main procedures of the FASTA program
can be described in the following steps [57]:
1.
Identify all k length regions
3
shared by the two sequences with the highest
density of identities.
The best 10 initial regions are used.
2.
Re-scan and re-score the best 10 initial regions along their lengths by ap-
plying a substitution matrix to identify the optimally scoring subregions.
3.
Conduct an alignment process of optimal regions using dynamic program-
ming.
Calculate a similarity score that is used to rank the library se-
quences.
4.
Optimise the alignment of the query sequence and the library sequences
using the Needleman-Wunsch algorithm.
FASTA format
Currently,
FASTA programs have been replaced by other advanced sequence
alignment software.
However,
the FASTA format is now used in biology and
bioinformatics ubiquitously, and has become the standard sequence format in
bioinformatics.
FASTA is a text-based format for representing either nucleotide sequences or
amino acid sequences, in which nucleotides or amino acids are represented using
single-letter codes.
In this format, sequence names and other information can
be provided.
A simple example of one sequence in FASTA format:
3
Sequence’s regions with the same length of k
18
Chapter 1.
Introduction
FASTA Format
> gi|387149188|ref|NC
0
17340.1|Staphylococcusaureus04
02981chromosome, completegenome
CGATTAAAGATAGAAATACACGATGCGAGCAATCAAATTTCATAACATCACCATGA
ATGAGTGTTTACAATGTTTGAATACCTTATACAGTTCTTATACATACTTTATAAAT
TTTTGATACACTCACTAACAGATATTCTATAGAAGGAAAAGTTATCCACTTATGCA
AGAATTGTGGATAATTAGAAATTACACACAAAGTTATACTATTTTTAGCAACATAT
Table 1.8:
An example of FASTA format
Clustal
The current Clustal programs all derive from Clustal-W
4
which was introduced
by Thompson in 1994,
and included position-specific scoring and weighting
schemes for down-weighting overrepresented sequence groups [79].
The pro-
grams user-friendliness was enhanced with the release of the graphical version,
Clustal-X
5
[78].
To increase accuracy, speed and sensitivity performance, the
Clustal
family programs have been improved upon many times since 1994.
More recently,
Clustal-Omega has become the latest addition to the Clustal
family [72].
The quality of alignments and scalability are superior to the pre-
vious versions, as measured by di↵erent benchmarks [31, 18].
Method
Compared to Clustals previous sequence alignment programs,
the major im-
provements introduced are to solve the alignment parameter choice problem
and the local minimum problem.
Clustal programs dynamically vary the gap
penalties in a position and residue-specific manner.
Moreover,
the locations
of the gaps found in the early alignments are also given reduced gap opening
penalties.
The two main series of
amino acid weight matrices that are used
4
The ‘W’ stands for ‘weights’
5
The ‘X’ stands for ‘x-window’
19
Chapter 1.
Introduction
today are the PAM series and the BLOSUM series.
Clustal
chooses di↵er-
ent weight matrices as the alignment proceeds,
depending on the estimated
divergence of the sequences to be aligned at each stage [18].
The main Clustal algorithms can be described in the following steps:
1.
Compute the pairwise similarity alignment score for all
sequences and
store in a matrix.
2.
Convert the sequence similarity values to distance measures.
3.
Construct a tree model (also called guide tree) for the order in which pairs
of sequences are to be aligned and combined with previous alignments.
4.
Progressively align the sequences/alignments together into each branch
point of the guide tree, starting with the least distant pairs of sequences.
In 2011,
an evolved and advanced version of
Clustal
was released for MSA,
named Clustal-Omega.
Clustal-Omega outperforms the previous version in
execution time and quality.
It also includes features for adding sequences to
and exploiting information in existing alignments,
making use of the prepro-
cessed information in public databases, such as Pfam [72].
Clustal-Omegas advantage is its progressive alignment approach to the guide
tree method.
Previously,
the only method that could routinely make align-
ments of more than 10,000 sequences was MAFFT/PartTree [30], an approach
that was fast but inferior in accuracy.
Clustal-Omega uses a modified mBed
Tree, which is fast with a time complexity of O(nlogn), producing guide trees
that are just as accurate as those using conventional methods [11].
20
Chapter 1.
Introduction
BLAST
Introduced in 1990, the Basic Local Alignment Search Tool (Blast) is the pri-
mary sequence alignment program in bioinformatics [3].
Blast is widely used
for protein and DNA sequences comparison, and it identifies library sequences
that resemble the query sequence above a certain threshold.
Traditionally,
conducting database searches for protein or nucleic acid sequences was very
time-consuming using a dynamic program, such as the Smith–Waterman algo-
rithm.
By developing its heuristic algorithms,
Blast is much faster than any
Smith–Waterman implementation [14].
There are a number of varieties of BLAST available.
MegaBlast and Blastp-
fast use the greedy algorithm for both nucleotide sequence and amino sequence
alignment searches.
These programs are optimised for aligning sequences that
di↵er slightly as a result of sequencing or other similar ‘errors’.
When a larger
word size is used,
these programs are up to 10 times faster than more com-
mon sequence similarity programs.
MegaBlast and Blastp-fast are also able
to efficiently handle much longer DNA sequences than the Blastn and Blastp
program of traditional Blast algorithms.
The table below shows main programs in the BLAST family.
Blast family programs
Name
Alignment Sequence Type
Blastn
Nucleotide to nucleotide
Blastp
Protein to protein
Blastx
Nucleotide 6-frame translation-protein
MegaBlast
Large numbers of query sequences
Table 1.9:
Blast family programs
Method
The main idea of
Blast
is
the identification of
significant
alignment
from
21
Chapter 1.
Introduction
high-scoring segment pairs in sequences.
Blast searches for high-scoring parti-
tion alignment between the query sequence and the existing sequences in the
database, using a heuristic algorithm other than dynamic programming [51].
The following process demonstrates the whole algorithm behind Blast.
1.
Remove low-complexity region or sequence repeats in the query sequence.
2.
Make a k-letter word (so-called kmer) list of the query sequence.
3.
List the possible matching words.
4.
Create a search tree to maintain the high-scoring words.
5.
Scan the database sequences for exact matches with the remaining high-
scoring words.
6.
Extend the exact matches to high-scoring segment pairs.
7.
Combine two or more high-scoring segment pairs into a longer alignment.
22
Chapter 1.
Introduction
1.4
Sequence Similarity Measurement
1.4.1
Research Data Preparation
In this research,
methods for sequence similarity measurement were investi-
gated and compared to current alignment programs, such as Blast and Clustal.
Thus, the selection of datasets for sequence search experiments was an impor-
tant step in this research.
Throughout the research phase for this thesis, arti-
ficial sequence datasets were generated from Alfsim [22] for sequence retrieval
purposes.
Alfsim is an artificial
life framework,
which aims at simulating the
entire range of evolutionary forces that act on genomes:
nucleotide, codon, or
amino acid substitution (under simple or mixture models), indels, GC-content
amelioration,
gene duplication,
gene loss,
gene fusion,
gene fission,
genome
rearrangement, lateral gene transfer (LGT) or speciation [22].
In this work,
the approaches and programs are evaluated on four di↵erent
datasets.
A DNA dataset (ALF-DNA) and two protein datasets (ALF-PROT-
S and ALF-PROT) were generated using Alfsim [22].
Another protein se-
quence dataset (Swiss-Prot) consists of
real-world gene sequences.
Detailed
information about DNA and protein sequence datasets is shown in the follow-
ing subsections.
DNA sequences dataset
The DNA dataset (ALF-DNA) was generated by Alfsim for preliminary re-
trieval experiments.
This dataset includes 15 species with each species includ-
ing about 200 genes.
Alfsim generates the species of this dataset based on a
‘BDTree’.
Sequence substitution is based on the ‘CPAM’ substitution model.
Here are some parameter details:
23
Chapter 1.
Introduction
• treeType := ’BDTree’
Method for creating the species tree.
’BDTree’
creates a birt-death tree with
distance mutRate from origin to leaves.
• birthRate := 0.01
For BDTree: birth rate.
• deathRate := 0.001
For BDTree: death rate.
• NSpecies := 15
The number of species in the tree.
• ultrametric := false
For BDTree:
should resulting tree be ultrametric (default true).
• mutRate := 250
Distance from origin to species at the leaves (for random trees)
• scaleTree := true
Set to true, if the branch lengths of the tree should be scaled.
When tree length
is defined as well, the sum of all branches will be scaled to match treeLength.
Otherwise, the distance from root to deepest leaf is scaled to match mutRate.
These are the parameters of sequence substitution model:
• substModels := [SubstitutionModel(’CPAM’)]
Use CPAM Substitution Model.
• indelModels := [IndelModel(0.0001, ZIPF, [1.821], 50)]
Define the insertion and deletion model.
Rate of
insertions and deletions:
0.0001.
Model
Type:
ZIPF (a Zipfian distribution).
Exponent of Zipfian dis-
tribution (1.821).
Max Length:50.
• rateVarModels := [RateVarModel(Gamma, 5, 0.01, 1)]
Models for rate variation.
Using Gamma distribution.
• modelSwitchS := [[1]]
A matrix with probabilities for a switch from sequence type Ti to type Tj after
speciation or duplication, respectively.
[[1]] means no switch.
24
Chapter 1.
Introduction
• modelSwitchD := [[1]]
A matrix with probabilities for a switch from sequence type Ti to type Tj after
speciation or duplication, respectively.
[[1]] means no switch.
Other details of the dataset are shown below.
ALF-DNA
Property
Value
Sequence count
3792
Species number
15
Max length
4432
Min length
37
Average length
1106
Table 1.10:
Details of DNA sequences dataset - ALF-DNA
Protein Sequences dataset 1
ALF-PROT-S (ALF-PROT-Standard) dataset is a protein sequence dataset
generated by Alfsim using default parameters.
This dataset includes 30 species
with each species containing about 200 genes.
Alfsim generated this dataset
using a default custom tree model.
Sequence substitution is based on the
‘WAG’
substitution model.
WAG (Whelan And Goldman) is an empirical
model
of globular protein evolution.
It was estimated from 182 protein fam-
ilies (provided by David Jones) using a maximum likelihood procedure that
takes into account the evolutionary relationships within each family.
WAG is
implemented in many widely used programs for phylogeny [35].
Here are some parameter details:
• substModels := [SubstitutionModel(’WAG’)]
Use WAG Substitution Model.
25
Chapter 1.
Introduction
• indelModels := [IndelModel(0.00005, ZIPF, [1.821], 50)]
Define the insertion and deletion model.
Rate of
insertions and deletions:
0.00005.
Model
Type:
ZIPF (a Zipfian distribution).
Exponent of
Zipfian
distribution (1.821).
Max Length:50.
• rateVarModels := [RateVarModel()]
Models for rate variation.
Using default settings.
• modelSwitchS := [[1]]
A matrix with probabilities for a switch from sequence type Ti to type Tj after
speciation or duplication, respectively.
[[1]] means no switch.
• modelSwitchD := [[1]]
A matrix with probabilities for a switch from sequence type Ti to type Tj after
speciation or duplication, respectively.
[[1]] means no switch.
Gene duplication parameters are shown below:
• geneDuplRate := 0.001
Rate of gene duplications (relative to substitutions).
• numberDupl := 5
Maximum number of consecutive genes involved in one duplication event.
• transDupl := 0
Probability of a tranlocation after duplication.
• fissionDupl := 0
Probability of a fission event after the duplication of a single gene.
• fusionDupl := 0
Probability of a fusion event after the duplication of two or more genes.
• P pseudogene := 0
Probability of duplicate becoming a pseudogene (permanent rate change
for duplicate).
• P neofunc := 0
Probability of duplicate undergoing neofunctionalization (temporary rate
change for duplicate).
26
Chapter 1.
Introduction
• P subfunc := 0
Probability of
both copies undergoing subfunctionalization (temporary
rate change for original and duplicate)
Other details of the dataset are shown as below.
ALF-PROT-S
Property
Value
Sequence count
6359
Species number
30
Max length
4554
Min length
50
Average length
1502
Table 1.11:
Details of Protein sequences dataset - ALF-PROT-S
Protein Sequences dataset 2
Protein (ALF-PROT) sequence is another dataset with more amino acid in-
sertion, deletion and substitution, produced by Alfsim.
This dataset was pro-
duced as an additional
dataset to measure the sequence retrieval
approaches
in this research.
It needs to be emphasised that this dataset is generated with special mutation
parameters in the Alfsim, and is designed to be challenging for both alignment
based and alignment-free approaches.
This dataset is a good sample for us
to keep improving the performance and finding limitations of
representation
methods in this research.
This dataset includes 30 species.
we generated this dataset species using a
‘BDTree’ model.
Similar to ALF-PROT-S, it uses a ‘WAG’ model for sequence
Substitution.
Here are some parameter details:
27
Chapter 1.
Introduction
• treeType := ’BDTree’
Method for creating the species tree.
’BDTree’
creates a birt-death tree with
distance mutRate from origin to leaves.
• mutRate := 100
Distance from origin to species at the leaves (for random trees)
• birthRate := 0.01
For BDTree: birth rate.
• deathRate := 0.001
For BDTree: death rate.
• NSpecies := 30
The number of species in the tree.
• protStart := 1000
The number of sequences that the first organism should have (only if the root
genome is generated).
Gene duplication parameters:
• geneDuplRate := 0.017
Rate of gene duplications (relative to substitutions).
• numberDupl := 1
Maximum number of consecutive genes involved in one duplication event.
• geneLossRate := 0.017
Rate of gene losses (relative to substitutions)
• numberLoss := 1
Maximum number of consecutive genes involved in one loss event.
• lgtRate := 0.0125
Rate of single lateral gene transfers (relative to substitutions).
• orthRep := 1
Proportion of lateral gene transfers that are orthologous replacements.
• invers := 0.0025
Rate of gene inversions (relative to substitutions).
28
Chapter 1.
Introduction
• invSize := 1
Size of inversions.
• transloc := 0.0025
Rate of gene translocations (relative to substitutions).
• transSize := 1
Maximum number of genes which are translocated in one go.
• fissionRate := 0.001
Rate of gene fissions without prior duplication (relative to substitutions).
• fusionRate := 0.001
Rate of gene fusions without prior duplication of fused genes (relative to sub-
stitutions).
Other details of the ALF-PROT dataset:
Details of protein sequences dataset - ALF-PROT
Property
Value
Sequence count
4000
Species number
30
Max length
1990
Min length
51
Average length
351
Table 1.12:
Details of protein sequences dataset - ALF-PROT
Swiss-Prot - Protein sequences dataset from the real-world
Swiss-Prot is a protein sequence database which strives to provide a high level
of annotation, such as the description of the function of a protein, its domains
structure, post-translational modifications, variants, a minimal level of redun-
dancy and high level
of integration with other databases [5].
The Swiss-Prot
29
Chapter 1.
Introduction
dataset downloaded from UniProt
6
includes manually annotated information.
The meta-data of Swiss-Prot also includes manually labelled families.
The following two tables show two sequence examples from Swiss-Prot.
FASTA Format - Swiss-Prot
> sp|Q6GZX4|001R
F
RG3GP utativetranscriptionfactor001ROS = F rogvirus3GN = F V 3
001RP E = 4SV =
1
MAFSAEDVLKEYDRRRRMEALLLSLYYPNDRKLLDYKEWSPPRVQVECPKAPVEWNNPPS
EKGLIVGHFSGIKYKGEKAQASEVDVNKMCCWVSKFKDAMRRYQGIQTCKIPGKVLSDLD
AKIKAYNLTVEGVEGFVRYSRVTKQHVAAFLKELRHSKQYENVNLIHYILTDKRVDIQHL
EKDLVKDFKALVESAHRMRQGHMINVKYILYQLLKKHGHGPDGPDILTVKTGSKGVLYDD
SFRKIYTDLGWKFTPL
> sp|Q6GZX3|002L
F
RG3GUncharacterizedprotein002LOS
= F rogvirus3(isolateGoorha)GN
= F V 3
002LP E = 4SV = 1
MSIIGATRLQNDKSDTYSAGPCYAGGCSAFTPRGTCGKDWDLGEQTCASGFCTSQPLCAR
IKKTQVCGLRYSSKGKDPLVSAEWDSRGAPYVRCTYDADLIDTQAQVDQFVSMFGESPSL
AERYCMRGVKNTAGELVSRVSSDADPAGGWCRKWYSAHRGPDQDAALGSFCIKNPGAADC
KCINRASDPVYQKVKTLHAYPDQCWYVPCAADVGELKMGTQRDTPTNCPTQVCQIVFNML
DDGSVTMDDVKNTINCDFSKYVPPPPPPKPTPPTPPTPPTPPTPPTPPTPPTPRPVHNRK
VMFFVAGAVLVAILISTVRW
Table 1.13:
Swiss-Prot.
A sample of annotated sequence
Details of protein sequences dataset - ALF-PROT
SwissProt Ac-
cession ID
Long ID
Protein Name
Family ID
Family Description
Q6GZX4
001R FRG3G
Putative tran-
scription
fac-
tor 001R
Pox VLTF3
Poxvirus Late Transcrip-
tion Factor VLTF3 like
Q6GZX3
002L FRG3G
Uncharacterized
protein 002L
DUF230
Poxvirus proteins of
un-
known function
Table 1.14:
Swiss-Prot.
A sample of meta data
In this research,
Swiss-Prot was utilised for measuring the performance of
kmer and gene sequence representation, derived from neural network precision
in sequence retrieval
and comparison tasks.
Swiss-Prot is a huge dataset,
with more than 320,000 sequences.
In this work,
a small
sub-dataset (5000
sequences) was extracted randomly and used in the experiments.
6
http://www.ebi.ac.uk/swissprot/
30
Chapter 1.
Introduction
Details of protein sequences dataset - Swiss-Prot
Property
Value
Sequence count
5000
Family number
50
Max length
3055
Min length
37
Average length
382
Table 1.15:
Details of protein sequences dataset - Swiss-Prot
1.4.2
Precision and Recall Evaluation for Sequence Re-
trieval Experiments
The precision and recall curve was used to measure the performance of di↵erent
approaches and programs.
In information retrieval,
precision and recall
are
defined regarding a set of
retrieved documents (e.g.
sequences with a high
similarity score for a query) and a set of relevant documents (e.g.
all
related
sequences) [59].
The calculation of
precision and recall
values is presented
using the following equations.
P recision =
Number of retrieved relevant genes
Total number of all retrieved genes
=
T P
T P + F P
(1.1)
Recall =
Number of retrieved relevant genes
Total number of all relevant genes
=
T P
T P + F N
(1.2)
TP represents true positive.
FP represents false positive.
FN stands for false
negative.
31
Chapter 1.
Introduction
Mean Average Precision
Mean average precision (MAP) provides a single-figure measure of
quality
across recall
levels.
Among evaluation measures,
MAP has been shown to
have especially good discrimination and stability.
For a single information
need,
average precision is the average of the precision value obtained for the
set of top k documents existing after each relevant document is retrieved, and
this value is then averaged over information needs [38].
MAP =
1
Q
Q
X
j=1
1
m
j
m
j
X
k=1
P recision(R
jk
)
(1.3)
Q is the total
number of relevant documents in the collection.
R
jk
is the set
of ranked retrieval results from the top j
th
to the k
th
document.
1.4.3
Sequence Retrieval
Experiment using Blast and
Clustal
In this experiment, Blast
7
and Clustal-Omega were utilised for conducting the
alignment process and retrieval of the homologous sequences for both DNA and
protein datasets.
The precision and recall curves were created based on align-
ment results,
which were performed as the benchmarks of sequence retrieval
and search experiments in this research.
ALF-DNA
As shown in Figure 1.3, Blastn and Clustal-Omega achieved similar precision
in the ALF-DNA sequence retrieval
experiment.
MegaBlast was much faster
7
Blastn and MegaBlast for DNA sequences.
Blastp and Blastp-fast for protein
sequences.
32
Chapter 1.
Introduction
in sequence searching.
However, the sequence retrieval precision also dropped.
Figure
1.3:
ALF-DNA sequences
retrieval
experiment
using
Blastn,
MegaBlast and Clustal-Omega.
Mean Average Precision
Program Name
MAP
Clustal-Omega
0.79
MegaBlast
0.41
Blastn
0.82
Table 1.16:
MAP of Blastn, MegaBlast and Clustal in ALF-DNA sequences
retrieval experiment
Table 1.16 indicates the mean average precision of the sequence retrieval
re-
sult from Blastn,
MegaBlast and Clustal-Omega.
Blastn and Clustal-Omega
achieved around 0.8 average precision, whereas MegaBlast achieved 0.41 aver-
age precision.
33
Chapter 1.
Introduction
ALF-PROT-S
For protein sequence dataset ALF-PROT-S, the performance of Blastp, Blastp-
fast and Clustal-Omega is shown in the following chart and table.
Figure 1.4:
ALF-Prot-S sequences retrieval experiment using Blastp, Bastp-
fast and Clustal-Omega.
Mean Average Precision
Program Name
MAP
Clustal-Omega
0.89
Blastp-fast
0.87
Blastp
0.94
Table 1.17:
MAP of Blast and Clustal
in ALF-PROT-S sequences retrieval
experiment
ALF-PROT
Similarly,
Blast and Clustal
were also used in the ALF-PROT sequence re-
trieval experiment.
The performance of Blastp, Blastp-fast and Clustal-Omega
is shown in the following chart and table.
34
Chapter 1.
Introduction
Figure 1.5:
ALF-Prot sequences retrieval
experiment using Blastp,
Bastp-
fast and Clustal-Omega.
This following table indicates the mean average precision of the sequence re-
trieval result of Blastp, Bastp-fast and Clustal-Omega.
As it is shown in this
sequence comparison result,
Clustal-Omega and Blastp-fast can only achieve
0.64 and 0.71 average precision for this dataset.
This result indicates that com-
pared to ALF-PROT-S,
ALF-PROT is more challenging for alignment based
approaches in this research.
Mean Average Precision
Program Name
MAP
Clustal-Omega
0.64
Blastp-fast
0.71
Blastp
0.93
Table 1.18:
MAP of
Blast and Clustal
in ALF-PROT sequences retrieval
experiment
35
Chapter 1.
Introduction
Swiss-Prot
We also applied Blast and Clustal-Omega to Swiss-Prot sequence dataset.
Their performances are showing as below.
Figure 1.6:
Swiss-Prot sequences retrieval
experiment using Blastp,
Bastp-
fast and Clustal-Omega.
The following table indicates their mean average precision.
Mean Average Precision
Program Name
MAP
Clustal-Omega
0.78
Blastp-fast
0.77
Blastp
0.87
Table 1.19:
MAP of
Blast and Clustal
in Swiss-Prot sequences retrieval
experiment
36
Chapter 1.
Introduction
1.5
Discussion and Conclusion
As described in this chapter,
MSA has played a significant role in bioinfor-
matics and molecular biology research.
Next Generation Sequencing (NGS)
technologies have led to an explosion in genetic and genomic datasets,
which
has posed a significant challenge to existing sequence processing and search-
ing methods.
At present,
such processes are commonly conducted by Blast
and Clustal,
the alignment-based similarity determination tools.
However,
alignment-based approaches do not adapt well when facing the larger datasets,
nor for mutation and rearrangement of large gene fragments.
Due to the above mentioned adaptation problems,
this research has investi-
gated other approaches.
Novel representation methods have many advantages
in searching and similarity detection tasks.
With the help of machine learning
approaches, this research tries to demonstrate the desirable performance of rep-
resentation methods in the efficiency and accuracy of sequence searching tasks.
In the next chapter,
these representations are described from an information
retrieval perspective and are compared to sequence alignment programs, such
as Blast and Clustal-Omega.
37
Chapter 2
Representation Methods for
Sequence Retrieval
2.1
Sequence Alignment-free Method
The measurement of sequence similarity is fundamental in bioinformatics and
computational
biology.
Sequence similarity measure problems are primarily
addressed through heuristic based alignment
programs,
such as
Blast
and
Clustal, which have underpinned many annotations and alignments in the ge-
nomic field.
Recently, other sequence data analysis methods, such as alignment-
free approaches,
have also begun to play an important role in the relevant
research [84].
Alignment-based approaches produce excellent results when the sequences un-
der study are closely related.
However,
despite the success of
these tools,
alignment-based methods do not work ideally in two key areas.
Firstly, alignment-
based methods are normally based on dynamic programming algorithms and
heuristic approaches, which means execution time increases quadratically when
38
Chapter 2.
Representation Methods for Sequence Retrieval
dealing with long sequences [33].
Secondly, alignment-based methods may not
be able to handle the structural
sequence rearrangements in sequences.
For
example, when related sequences vary, not only through small numbers of lo-
cation substitutions, insertions and deletions, but also through large fragment
rearrangement.
Large contiguous fragment rearrangement is important in the
research and development of infectious diseases and antibiotic resistance, often
involving a process known as Lateral
Genetic Transfer.
The development of
NGS technologies has resulted in the generation of a huge amount of sequenc-
ing data, which poses challenges to alignment-based algorithms.
Due to these
reasons,
alignment-free method analysis is currently under development for
sequence processing and has provided attractive alternatives over alignment
approaches [71].
Alignment-free methods are usually based on approaches,
such as kmer fre-
quency, information theory or graphical representation.
In this research, meth-
ods that are based on kmers are mainly considered.
2.1.1
Kmers
Alignment-free methods usually rely on short fragment sequences with a fixed
length of K, known as kmers.
Choices of K 2 {5, 6, 7, ..., 25} are often used for
nucleotide sequence (DNA) sequence analysis, while choices of K 2 {2, 3, ..., 7}
are considered suitable for the amino acid sequence.
Kmers are essential
to
the preprocessing of
the sequence.
A typical
procedure is to cut a sequence
into a series of overlapping kmers.
39
Chapter 2.
Representation Methods for Sequence Retrieval
ACGTAGCATTACTGATACGGT
ACGTA ATTAC ATACG
CGTAG TTACT TACGG
GTAGC TTACT ACGGT
Figure 2.1:
5mers in a nucleic acid sequence (DNA)
Figure 2.1 shows 5mers of
a nucleotide sequence.
The great advantage of
using kmers to support sequence analysis is the computational
convenience.
As shown in the figure,
kmers can be generated in parallel
from sequence
partitions.
In this chapter,
methods for creating representations of kmers and genes are
reported.
This verifies the feasibility and advantages of using representations as
a proxy of gene sequence to measure their similarity.
The experiments detailed
in this chapter also demonstrate the performance of
representation methods
in sequence searching and retrieval tasks compared to alignment programs.
40
Chapter 2.
Representation Methods for Sequence Retrieval
2.2
Representations in Information Retrieval
“Information retrieval
(IR) is finding material
of
an unstructured nature
that
satisfies an information need from within large collections (usually
stored on computers).” - Christopher D. Manning [38]
As before, we here use the term representation to refer to short binary or real-
valued vectors or strings used to represent the documents or other searchable
objects in a query.
In natural language processing, words are treated as atomic
units that are conventionally represented as indices in a vocabulary.
Using one-
hot representations, words are transformed into feature vectors with the same
length as the size of the vocabulary [24].
There are two main problems within
these one-hot word representations.
First,
the dimensionality of
the vector
is high.
Secondly,
data of the whole representation vectors are sparse.
Such
representations do not support semantic or syntactic similarity between words.
However, representation-based methods derived from original one-hot vectors
have been used widely for ad hoc retrieval of whole documents, as well as for
plagiarism detection [7].
Documents, such as books and papers, can be treated
as being composed of words.
Most information retrieval (IR) techniques rep-
resent documents as a bag-of-words, in which the model, order and structure
of words do not matter [55].
In contrast,
an n-gram is a contiguous sequence
of n sub-items from a given context, such as text or sequence [81].
The n-gram
model is widely used in statistical natural language processing,
speech recog-
nition and language identification.
This model
can also be used for sequence
data.
In bioinformatics, kmers may represent items of an n-gram, which have
been used in many types of
research,
such as extracting features for protein
sequence clustering [36].
In practice,
n-gram models have been shown to be
e↵ective in many scenarios.
However, there are still some criticisms that have
41
Chapter 2.
Representation Methods for Sequence Retrieval
been made towards n-gram models.
One disadvantage of an n-gram model is
that it lacks any explicit representation of long-range dependency.
In this chapter, novel methods are described for creating a representation for
kmers, which will be then used for representing the fragment or the whole gene
sequence.
In addition,
sequence similarity can be quickly determined by the
distance between representations.
The main purpose of
creating representa-
tions of kmers and genes is to overcome the inherent shortcomings of alignment
model.
2.3
Representations for Kmers and Sequences
There is a long history in information retrieval
of
object representations to
accelerate the searching process [38].
With increasing amounts of
text be-
ing searchable,
it was desirable to increase the performance of the searching
process.
The core concept is to build a proxy representation of
the object collection,
whether for documents, images or sequences.
Representation is treated as the
identification of an object for similarity or distance measurement.
Why do we use representations?
Representations
have many advantages
in search and classification related
tasks.
First of all, real value vectors in multiple-dimensional spaces are machine
friendly,
which are intuitive and convenient for calculation for each di↵erent
task.
Distance calculation between vectors can be easily conducted in parallel,
and the approach is suitable for GPUs.
The following figure shows a general
process of
creating representations for
kmers and genes for search and retrieval purposes.
42
Chapter 2.
Representation Methods for Sequence Retrieval
Sequence Group
Sequence 1
ACAGTGCATGCT
AGTCGATGCATG
CTAGCTAGCATG
CATGCATCGATG
T
Sequence 2
Sequence 3
Combine Kmer representation to 
sequence representation
Sequence 1 
Representation
[-0.233845 -0.0210749 
0.0271133 0.165561 
0.160609 -0.0005508 
-0.027172 -0.00250745 ]
Sequence 2
Sequence 3
Kmer Group
Seq5: kmer1, kmer2, ..., kmer3
Seq4: kmer1, kmer2, ..., kmer3
Seq3: kmer1, kmer2, ..., kmer3
Seq2: kmer1, kmer2, ..., kmer3
Seq1: kmer1, kmer2, ..., kmer3
Sequence comparison by 
calculating representation 
distance
Seq1 - Seq2: 1884.2
Seq2 - Seq3: 1700
Seq3 - Seq4: 1950
Seq4 - Seq5: 996
Seq1 - Seq6: 2000.2
Gene sequence search precision and 
recall measurement 
Generate Representation for each 
kmer
Kmer1: [0.1, 0.2, -0.3, 0.05, 
1.2, ... , 1.5, 1.2]
Kmer2: [0.3, 0.2, -0.3, 0.05, 
1.2, ... , 1.1, 1.2]
Kmer3: [0.6, 0.2, -0.3, 0.05, 
1.2, ... , 0.2, 1.2]
Kmer4: [0.0, 0.2, -0.3, 0.05, 
1.2, ... , 0.5, 1.2]
Sequence and Kmer 
Processing
Information Rretrieval: 
TF-IDF, Locality-
sensitive Hashing
Machine Learning: 
Autoencoder neural network, 
Semantic Network
Figure 2.2:
A general approach of generating representations for sequences.
43
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.2 shows the process of sequence representation generation.
Sequence
similarity can be computed rapidly through vector distance calculation without
resorting to dynamic programming or traversals of complex data structures.
Locality-sensitive hashing is a closely related work of representation methods,
based on the concept of creating an object hashing code, allowing these hash-
ing representations to be compared for both object recognition and similarity
measurement [73, 23].
The process of
creation representation for kmers and sequence is similar to
the word and document approach described by Larson in 1984 [38].
The basic
idea is to create an individual
representation for each particular word.
Then
word representations are concatenated or combined in various ways to form a
document representation.
2.3.1
Distance and Similarity Measurement
Measuring distance between signatures or representations has played an im-
portant role in this research.
In this research, real-valued representations were
initially created for kmers and sequences and the Euclidean distance was used
for measuring the distance between representations.
Binary valued signatures
converted from real
value vectors are also mentioned in the later chapters,
as the Hamming distance for binary code representations can be computed
quickly (Table 2.1).
Distance function
Distance method
Function Equation
Euclidean Distance
Dis(x, y) =
q
P
N
i=1
(x
i
y
i
)
2
Hamming Distance
Dis(x, y) =
P
N
i=1
|x
i
6= y
i
|
Table 2.1:
Distance function table.
Di↵erent representations fit di↵erent
distance function.
44
Chapter 2.
Representation Methods for Sequence Retrieval
2.4
Random Kmers and Sequences Represen-
tations
To create representations for kmers, a simple and intuitive way is to generate
unique vectors with random values to represent each kmer.
Algorithm 1 shows
a process to create representations for kmers and sequences.
Algorithm 1: Pseudo-code algorithm for generating random representa-
tions for kmers and sequences
begin
for Each kmer in sequences do
KmerSignature RandomVector(Kmer)
for Each sequence in sequences do
SequenceSignature CombinationFunction(KmerSignatures);
The combination function shown in algorithm 1 depends on the representation
type.
If we randomly generate real value vectors for kmer representations, then
kmer representations can be summed up to represent sequences.
For binary
value vectors,
we can get sequence representations from the union of
kmer
signatures.
After representations of sequences are created, the similarity of sequences can
be determined by calculating the distance between each pair representation.
2.4.1
Sequence Retrieval Experiment
ALF-DNA sequence dateset
To measure the performance of
randomly generated representations for se-
quence similarity determination, we used the artificial DNA sequence dataset
(ALF-DNA) generated from Alfsim,
introduced in Chapter 1.
The dataset
45
Chapter 2.
Representation Methods for Sequence Retrieval
included 3972 di↵erent nucleotide sequences from 15 di↵erent species.
In this
experiment, real-valued representations of kmers and sequences were generated
using Algorithm1.
Firstly,
the representations for each 6mer were generated
randomly.
Then the 6mer representations were summed up to perform as a
sequence representation.
The similarity between each pair of
sequences was
determined by Euclidean distance.
In this experiment,
the precision and recall
curve was used to measure the
performance of random kmer representations.
Figure 2.3:
ALF-DNA Sequence retrieval
precision and recall
-
Random
representations.
Mean Average Precision
Kmer length
Representation
length
MAP
6mer
512
0.385
6mer
1024
0.411
6mer
2048
0.417
Table 2.2:
MAP of Random Representations in ALF-DNA Sequence retrieval
experiment.
46
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.4:
ALF-DNA Sequence retrieval
precision and recall
-
Random
representations for di↵erent length of kmers.
Mean Average Precision
Kmer length
Representation
length
MAP
5mer
512
0.567
6mer
512
0.411
7mer
512
0.302
Table 2.3:
MAP of Random Representations in ALF-DNA Sequence retrieval
experiment.
According to these sequence comparison results,
1024 length representations
of 6mers achieve 0.41 average precision, whereas precision of 512 length repre-
sentation is 0.38.
For the di↵erent length of kmers, random representations of
shorter kmers (5mer) can achieve better precision (0.56).
As longer representations can maintain more information inside,
it is reason-
able that longer representations can achieve better precision in the retrieval
experiment.
But when the length of
signatures increases to 2048,
precision
stops increasing.
47
Chapter 2.
Representation Methods for Sequence Retrieval
To explain this phenomenon, we could refer to the ideas of the hashing function.
When the size of hashing table is small, the collision
1
has more chance to occur.
Larger hashing table would reduce the chance of collision.
When the size of
hashing table increases to a certain point, the chance of collision tends to reach
the lowest level.
In this work, the length of representation depends on both length and number
of sequences in the dataset.
In this dataset,
the “collision” between the rep-
resentation of kmers has a lower chance to occur when the length increase to
2048.
However, considering computational efficiency in representation distance
measurement, we mainly use the length of 512 in this work.
ALF-PROT-S sequence dateset
To measure the random representations for protein sequence searching,
the
same experiment was conducted on the ALF-PROT-S sequence dataset.
Two
di↵erent lengths of
representations for 3mers were randomly generated and
then used to compare gene sequences.
The precision and recall curve is shown
below.
1
A collision occurs when two objects hash to the same value
48
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.5:
ALF-PROT-S sequence retrieval
precision and recall
- Random
representations.
Mean Average Precision
Kmer length
Representation
length
MAP
3mer
256
0.33
3mer
512
0.36
Table 2.4:
MAP of Random Representations in ALF-PROT-S sequence re-
trieval experiment.
In this experiment, we use short representations (256 and 512).
They can basi-
cally achieve the same precision (0.33 to 0.36).
To compare the di↵erent length
of kmers,
in the following figures,
it is shown that random representations of
3mer can achieve the best result in ALF-PROT-S dataset.
49
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.6:
ALF-PROT-S sequence retrieval
precision and recall
- Random
representations for di↵erent length of kmers.
Mean Average Precision
Kmer length
Representation
length
MAP
3mer
512
0.36
4mer
512
0.27
5mer
512
0.23
6mer
512
0.20
Table 2.5:
MAP of Random Representations in ALF-PROT-S sequence re-
trieval experiment.
According to Figure 2.6 and Table 2.5, representation of 3mers can achieve the
best precision result (0.36 MAP).
ALF-PROT sequence dataset
Likewise,
same random representations are also applied to ALF-PROT for
sequence comparison purpose.
The precision and recall curve is shown below.
50
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.7:
ALF-PROT sequence retrieval
precision and recall
-
Random
representations.
Mean Average Precision
Kmer length
Representation
length
MAP
3mer
256
0.2239
3mer
512
0.2282
Table 2.6:
MAP of
Random Representations in ALF-PROT sequence re-
trieval experiment.
51
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.8:
ALF-PROT sequence retrieval
precision and recall
-
Random
representations for di↵erent length of kmer.
Mean Average Precision
Kmer length
Representation
length
MAP
3mer
512
0.2282
4mer
512
0.2027
5mer
512
0.1920
6mer
512
0.1846
Table 2.7:
MAP of
Random Representations in ALF-PROT sequence re-
trieval experiment.
Using random 3mer representations in protein sequence searching only achieves
0.22 - 0.23 mean average precision.
As shown in Figure 2.7,
precision drops
very fast at the early stage.
Random representations are straightforward and fast to create for kmers and
genes.
However,
the information embedded in the signature is not specific to
the kmer content.
As seen from this experiment, precision and recall value is
very low compared to Blast and Clustals.
52
Chapter 2.
Representation Methods for Sequence Retrieval
2.5
Locality Sensitive Hashing
Locality-sensitive hashing (LSH) is based on the idea that if two objects are
close together,
then after a projection,
these two objects should remain close
together.
Essentially, LSH is a dimensionality reduction method, which trans-
forms the original
representation of
an information object,
such as a very
sparse and high-dimensional feature vector, to a dense and fixed lower dimen-
sional representation [73, 23].
LSH allows for the similarity comparison of two
di↵erent objects more efficiently than traditional methods, such as cosine simi-
larity, if the original source object is large.
Moreover, the projection operation
of
LSH still
maintains the original
objects correlations from high dimension
to low dimension to achieve a high precision in searching.
These properties of
LSH motivate many applications in information retrieval, searching and dupli-
cate detection.
There are a large number of di↵erent LSH models in use, such
as Minhash [54],
Simhash [75]
and Random Indexing [66].
TopSig is a very
efficient searching tool based on Random Indexing [26].
2.5.1
Reflective Random Indexing
Another general
idea of
the implementation of
LSH is that of
word space
models, which use distributional statistics to generate high-dimensional vector
spaces.
In the method of a standard word space model,
the core idea is that
semantic similarity can be represented as proximity in multiple-dimensional
spaces.
TopSig is a state-of-the-art open source signature-based search engine.
TopSig relies on reflective random indexing (RI or LSH-RI), an efficient form of
random projection for highly sparse data in which vectors consist of randomly
and sparsely distributed +1 and -1 values in a vector that otherwise consists
mostly of zeros.
All
these relevant works provide ideas in creating signatures
for sequences and use fast sequence similarity determination [26].
53
Chapter 2.
Representation Methods for Sequence Retrieval
Sahlgren (2005) introduced an efficient implementation of LSH called Random
Indexing or Reflective Random Indexing (RI or LSH-RI). This method uses a
word space model
to create word representations based on a random projec-
tion of the object from its original
space to a reduced dimensional
subspace,
whereby the distance relationships between objects can still be preserved.
The
basic idea of
LSH-RI is to accumulate context vectors based on the occur-
rence of words in contexts.
The approach can be used in any context, such as
documents, texts or sequences [66].
The main procedure of the LSH-RI method can be implemented in two main
steps:
1.
Randomly generate and assign a unique representation (vectors) to each
context
2
.
These vectors are sparse and high-dimensional.
Normally, they
comprise a small number of randomly distributed entries of 1 and -1, with
the rest of the elements of the vectors set to 0.
2.
Scan the context and each time an object occurs in the context;
the
representation of context is then added to the objects representation.
In this work, the kmers and gene sequences representations are generated using
the LSH-RI approach.
The algorithm of the LSH-RI procedure for kmer and
2
Context represents document or sequences
54
Chapter 2.
Representation Methods for Sequence Retrieval
gene sequences is shown below.
Algorithm 2: Reflective Random Indexing Represenations for Kmers
Data:
Gene Sequences
Result:
Kmers Reflective Random Indexing Representations
!
GR:
Gene Ramdom Representation Vector
!
KR:
Kmer Representation Vector
begin
for Each gene sequence do
!
GR Randomlygeneratedvectorcontains{-1,0,1}
for Each kmer in gene sequence do
if Kmer Representation does not exist then
!
KR initialvectorcontains{0}
else
!
KR 
!
KR +
!
GR
Return all kmer signature (
!
KR) vectors
2.5.2
Sequence Retrieval Experiment
To measure the performance and precision of
gene sequence similarity using
kmer and gene sequence representations from an LSH-RI approach,
we again
use the artificial
DNA and protein sequence dataset and Swiss-Prot dataset.
In the following experiments,
LSH-RI representation is mainly compared to
random representations.
ALF-DNA sequence retrieval experiment
The precision and recall curve of DNA sequence searching is shown below.
In
Figure 2.9 and table 2.8,
sequence retrieval
results show that LSH-RI kmer
representations perform much better than random representations.
The mean
55
Chapter 2.
Representation Methods for Sequence Retrieval
average precision of the LSH-RI method in DNA sequence searching reaches
0.57 (representation length of 1,024), increasing by 16% compared to the ran-
dom representation approach.
Figure 2.9:
ALF-DNA sequence retrieval
precision and recall.
Reflective
Random Indexing Representations
Figure 2.10:
ALF-DNA sequence retrieval
precision and recall.
Reflective
Random Indexing Representations for di↵erent length of kmers.
56
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
5mer
512
0.56
Random
6mer
512
0.39
Random
7mer
512
0.30
LSH-RI
5mer
512
0.56
LSH-RI
6mer
512
0.55
LSH-RI
7mer
512
0.69
Table 2.8:
MAP of random and locality-sensitive hashing (reflective random
indexing) representation approaches for ALF-DNA sequence retrieval
experi-
ments.
We can see from this result, LSH-RI representation can achieve the best preci-
sion based on 7mers in ALF-DNA sequence comparison, with average precision
reaching 0.69.
ALF-PROT-S sequence retrieval experiment
In ALF-PROT-S protein sequence datasets,
sequence comparison results us-
ing LSH-RI representation show that the mean average precision significantly
increased to 0.69 and 0.71, increasing by 30% compared to the random repre-
sentation approach.
57
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.11:
ALF-PROT-S sequence retrieval precision and recall - Reflective
Random Indexing Representations
Figure 2.12:
ALF-PROT-S Sequence retrieval
precision and recall
- Reflec-
tive Random Indexing Representations for di↵erent length of kmers.
Figure 2.12 and Table 2.9 shows that when the length of
kmer equals 3,
it
reaches the best result.
58
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
256
0.33
Random
3mer
512
0.36
Random
4mer
512
0.27
Random
5mer
512
0.23
Random
6mer
512
0.20
LSH-RI
3mer
256
0.69
LSH-RI
3mer
512
0.71
LSH-RI
4mer
512
0.50
LSH-RI
5mer
512
0.42
LSH-RI
6mer
512
0.35
Table 2.9:
MAP of
random and locality-sensitive hashing (reflective ran-
dom indexing) representation approaches for ALF-PROT-S sequence retrieval
experiments.
ALF-PROT sequence retrieval experiment
In the ALF-PROT protein sequence retrieval
experiment,
the result shows a
similar trend.
The mean average precision of the LSH-RI method in protein
sequence searching reaches 0.32 (representation length of 512) which also over-
takes that of random representations.
59
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.13:
ALF-PROT Sequence retrieval precision and recall - Reflective
Random Indexing Representations
Figure 2.14:
ALF-PROT Sequence retrieval precision and recall - Reflective
Random Indexing Representations for di↵erent length of kmers.
60
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
256
0.2239
Random
3mer
512
0.2282
Random
4mer
512
0.2027
Random
5mer
512
0.1920
Random
6mer
512
0.1846
LSH-RI
3mer
256
0.2916
LSH-RI
3mer
512
0.3192
LSH-RI
4mer
512
0.2428
LSH-RI
5mer
512
0.2218
LSH-RI
6mer
512
0.2090
Table 2.10:
MAP of random and locality-sensitive hashing (random indexing)
representation approaches for ALF-PROT sequence retrieval experiments.
The previous figure demonstrates that kmer length is also critical
to the re-
trieval
precision result.
In the ALF-PROT dataset,
it reaches the best result
(0.32 MAP) when kmer length is 3.
Swiss-Prot sequence retrieval experiment
For the real-world dataset Swiss-Prot, the performance of LSH-RI representa-
tion is shown in the following figures.
61
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.15:
Swiss-Prot Sequence retrieval
precision and recall
- Reflective
Random Indexing Representations for di↵erent length of kmers.
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
LSH-RI
3mer
512
0.52
LSH-RI
4mer
512
0.35
LSH-RI
5mer
512
0.28
LSH-RI
6mer
512
0.25
Table 2.11:
MAP of locality-sensitive hashing (random indexing) represen-
tation approaches for Swiss-Prot sequence retrieval experiments.
Similar to random kmer representation,
the LSH-RI method also utilises the
unique property of a randomly generated vector.
Instead of generating kmer
representation directly,
the LSH-RI method randomly creates the represen-
tation for each sequence first.
Then it creates kmer representation based on
sequence representation.
Using this method,
kmers representations are close
62
Chapter 2.
Representation Methods for Sequence Retrieval
when they occur in the same sequences.
The LSH-RI method sets up a bridge
between di↵erent kmers using current sequence data that embed kmers and
sequence relationship information in their representation.
It shows in previ-
ous experimental
results that kmer representation created using an LSH-RI
approach increases searching and retrieval precision.
2.6
TF-IDF Representation
As described in previous sections, randomly generated kmer representation is
feasible in measuring sequence similarity based on distance.
However,
preci-
sion is low and difficult to improve due to their random properties.
LSH-RI
representation has increased sequence retrieval
precision because kmers are
projected together when they occur in the same sequences.
In a sense,
LSH-
RI tries to build connections between kmers and sequences using the current
dataset.
Following on from this method,
there are some other approaches
which can help to create kmer and sequence representation using existing in-
formation and knowledge of the sequence and dataset.
TF-IDF is another approach in creating word or document representations.
TF-IDF refers to the term frequency to inverse document frequency, which is
a numerical
statistic that is intended to reflect how important a term is to a
context in a collection.
Variations of the TF-IDF methods are often used in
ranking a documents relevance and scoring results from search engines [60, 2].
Term Frequency (TF) measures how frequently a term occurs in a document.
Since every document is di↵erent in length,
it is possible that a term would
appear many more times in longer documents than shorter ones.
Thus,
the
TF is often divided by the document length (the total number of terms in the
document) to normalise the measurement [64].
Inverse Document Frequency
(IDF) illustrates how important a term is in the context of
the collection.
63
Chapter 2.
Representation Methods for Sequence Retrieval
While computing TF, all terms are considered equally important.
However, it
is known that certain terms may appear many times,
but have little discrim-
inatory value.
Thus, we need to weigh down the frequent terms while scaling
up the rare ones [64].
TF-IDF has been successfully used in many circumstances in natural language
processing.
For example, variations of the TF-IDF weighting scheme are used
by search engines as a central
tool
in scoring and ranking a documents rele-
vance, given a user query.
However, to adapt a TF-IDF approach to sequence
datasets, some theoretical supports and connections between natural language
and genomic sequences still need to be addressed.
One of the most obvious facts about the human language is that there are a
few very high-frequency words that exist in texts (e.g.
a,
the,
I,
etc.).
The
word distribution roughly obeys a simple rule known as Zipfs law.
Zipfs law
is an empirical
distribution applicable to a range of data sets in the physical
and social sciences [58].
Zipf’s law indicates that the ith most frequent object
will
appear 1/i
✓
times the frequency of the most frequent object,
or that the
ith most frequent object from an object “vocabulary” of size V occurs
O(i) =
n
i
✓
H
✓
(V )
(2.1)
times in a collection of
n objects,
where H
✓
(V ) is the harmonic number of
order ✓ of V .
H
✓
(n) =
n
X
i=1
1
i
✓
(2.2)
In general,
Zipf’s law states that given some corpus of natural
language,
the
frequency of
any word is inversely proportional
to its rank in the frequency
64
Chapter 2.
Representation Methods for Sequence Retrieval
table.
Thus the most frequent word will occur approximately twice as often as
the second most frequent word, three times as often as the third most frequent
word, etc.:
the rank-frequency distribution is an inverse relation [4].
The following figure is a plot of word distributions for di↵erent languages that
fit Zipf’s law.
Figure 2.16:
A log-log scale plot of the rank versus frequency for the first 10
million words in Wikipedias in 30 languages [49].
Similarly,
it is easy to plot and measure kmers frequency and ranking distri-
bution if this particular sequence dataset fits Zipfs law.
65
Chapter 2.
Representation Methods for Sequence Retrieval
(a)
Kmer (3mer) frequency-ranking plot
(b)
Kmer (3mer) log-log plot
Figure 2.17:
A plot of frequency versus rank for all kmers (3mers) in Swiss-
Prot.
It can be seen in Figure 2.17 that kmer frequency drops very quickly at the
early stage and log-log plotting is basically linear, which indicates that kmers
in a Swiss-Prot sequence dataset broadly fit Zipf’s law.
Thus, we may be able
to utilise TF-IDF weights successfully in kmers and sequences based on this
observation.
The following equations show how TF-IDF is calculated for a collection of
genes.
T F (kmer) =
Number of times kmer appears in a gene sequence
Total number of kmers in the gene
(2.3)
IDF (kmer) = log
e
Total number of genes
Number of genes with kmer in it
(2.4)
T F IDF (kmer) = T F (kmer) ⇤ IDF (kmer)
(2.5)
66
Chapter 2.
Representation Methods for Sequence Retrieval
TF-IDF weight is simple and intuitive to compute.
In this research, a unique
representation for each kmer was generated using a TF-IDF approach,
de-
scribed in the following algorithm.
Algorithm 3: Generating TF-IDF Represenations for Kmers
Data:
Gene Sequences
Result:
Kmers TF-IDF Representations
Input:
S - Size of Kmer representation.
K - kmer size.
S Gene families
from Swiss-Prot dataset, with each family contains N sequences.
begin
Select
for Each kmer do
for Each gene family i
do
TF(kmer) = Number of times kmer appears in the family[i] /
Total number of kmers in the family[i]
IDF(kmer) = Log(Total number of genes in the family[i] /
Number of genes with kmer in the family[i])
TFIDF-Representation[kmer][i] = TF(kmer) * IDF(kmer)
Return TFIDF-Representation
Please notice that in order to create a vector representation for every kmer us-
ing a TF-IDF approach, it is essential to calculate TF-IDF weights of kmers for
di↵erent gene families.
To evaluate the performance of TF-IDF representation,
we only conducted the experiments on a Swiss-Prot dataset in this research,
as we use the Swiss-Prot gene family information to construct TF-IDF repre-
sentations for kmer and genes which is not provided by Alfsim datasets.
2.6.1
Swiss-Prot sequence retrieval experiment
According to algorithm 3, the length of kmer representation is associated with
the number of
gene families.
In this experiment,
in order to create kmer
representations with length of
512,
we randomly select 512 protein families
67
Chapter 2.
Representation Methods for Sequence Retrieval
from Swiss-Prot, with each family including 20 to 50 sequences.
In this experiment, representations generated using TF-IDF method were com-
pared to LSH-RI kmer representation.
In Figure 2.18, it is clearly shown that
TF-IDF representations generated from algorithm 3 perform better than LSH-
RI representations.
When k (length of
kmer) equals 4,
it reaches the best
precision (0.61).
Figure 2.18:
Swiss-Prot sequence retrieval
precision and recall
-
TF-IDF
representations.
68
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
LSH-RI
3mer
512
0.52
LSH-RI
4mer
512
0.35
LSH-RI
5mer
512
0.28
LSH-RI
6mer
512
0.25
TF-IDF
3mer
512
0.58
TF-IDF
4mer
512
0.61
TF-IDF
5mer
512
0.56
TF-IDF
6mer
512
0.51
Table 2.12:
MAP of Swiss-prot sequence retrieval.
Compare di↵erent repre-
sentation methods with di↵erent length of kmer.
The TF-IDF approach that is discussed in this section provides an alternative
means to create representations for kmers.
Compared to the LSH-RI method,
kmer representations generated by the TF-IDF method not only consider the
relationship between kmers and sequence,
they also reflect and embed gene
family information in their representations.
It is demonstrated in the previ-
ous results that in the real-world sequences dataset such as Swiss-Prot,
with
the help of
gene family information,
TF-IDF can achieve better precision in
sequence retrieval tasks.
2.7
Compare Representation Approach to Se-
quence Alignment Tools
In previous DNA and protein sequence retrieval experiments, we saw the per-
formance of TF-IDF and LSH-RI approaches based on the representation dis-
69
Chapter 2.
Representation Methods for Sequence Retrieval
tance calculations.
In the following figures, the main results from each representation method have
been put together and compared to alignment approaches.
3
2.7.1
ALF-DNA sequence retrieval
In DNA sequence retrieval experiments, LSH-RI representation achieved 0.69
mean average precision (based on 7mers) which overtakes that of MegaBlast
(0.41).
However, the accuracy of the representation method is still lower than
Blastn (0.82) and Clustal-Omega (0.79).
Figure 2.19:
ALF-DNA sequence retrieval
precision and recall.
Comparing
locality-sensitive hashing methods (Reflective Random Indexing) to Blast and
Clustal-Omega
3
To evaluate the performance of TF-IDF representation, we only conducted the
experiments on a Swiss-Prot dataset in this research, as we use gene family informa-
tion to construct TF-IDF representations for kmer and genes which is not provided
by Alfsim datasets.
70
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
5mer
512
0.56
LSH-RI
7mer
512
0.69
Clustal-Omega
0.79
MegaBlast
0.41
Blastn
0.82
Table 2.13:
MAP of ALF-DNA sequence retrieval.
Compare representation
method to alignment approach.
2.7.2
ALF-PROT-S Sequence Retrieval
As shown in the following Figures,
the performance of LSH-RI (0.69 to 0.71)
is close to alignment approach (0.8) on average.
Figure 2.20:
ALF-PROT-S sequence retrieval precision and recall.
Compar-
ing locality-sensitive hashing methods (Reflective Random Indexing) to Blast
and Clustal-Omega
71
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
512
0.36
LSH-RI
3mer
512
0.71
Clustal-Omega
0.89
Blastp-fast
0.88
Blastp
0.94
Table 2.14:
MAP of ALF-PROT-S sequence retrieval.
Compares represen-
tation method to alignment approach.
2.7.3
ALF-PROT Sequence Retrieval
As shown in Figure 2.21 and Table 2.15, the LSH-RI approach achieves about
0.30 to 0.32 mean average precision.
In contrast, alignment tools such as Blastp
and its fast version perform better in protein sequence searching experiments,
which achieve 0.71 and 0.93 average precision respectively.
72
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.21:
ALF-PROT Sequence retrieval precision and recall.
Comparing
locality-sensitive hashing methods (Reflective Random Indexing) to Blast and
Clustal-Omega
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
256
0.2239
Random
3mer
512
0.2282
LSH-RI
3mer
256
0.2916
LSH-RI
3mer
512
0.3192
Clustal-Omega
0.64
Blastp-fast
0.71
Blastp
0.93
Table 2.15:
MAP of ALF-PROT sequence retrieval.
Compares representa-
tion method to alignment approach.
73
Chapter 2.
Representation Methods for Sequence Retrieval
2.7.4
Swiss-Prot sequence retrieval
In the real-world dataset Swiss-Prot, using the TF-IDF method, mean average
precision (0.61) is 10% to 23% higher than LSH-RI.
This result is still
lower
than Blastp.
But it is comparable to Clustal-Omega and Blastp-fast.
Figure 2.22:
Swiss-Prot Sequence retrieval
precision and recall.
Compares
locality-sensitive hashing methods (reflective Random Indexing) and TF-IDF
to Clustal and Blast
74
Chapter 2.
Representation Methods for Sequence Retrieval
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
LSH-RI
3mer
512
0.52
LSH-RI
4mer
512
0.35
TF-IDF
3mer
512
0.58
TF-IDF
4mer
512
0.61
Clustal-Omega
0.76
Blastp-fast
0.77
Blastp
0.87
Table 2.16:
MAP of Swiss-Prot sequence retrieval.
Compares representation
method to alignment approach.
2.7.5
Efficiency and Speed
The efficiency of a representation approach in sequence comparison tasks is a
major concern in this chapter.
In this section, we only compare the efficiency
and time complexity of Blast to representation approach due to the fact that
Blast is the most efficient alignment program which reviewed in this work.
As described in Blast paper,
searching a Blast database of
N sequences for
similarity to a query sequence,
the time complexity is approximate O(aW +
bN + cNW/20
w
), where W is the number of kmers generated, N is the number
of sequences in the database and a,
b and c are constants [3].
Therefore,
for
N query sequences, the time complexity is approximately O(N ⇤ (aW + bN +
cNW/20
w
)) on average.
However, using the representation method, we only need to calculate the dis-
tance between representations,
it would only take O(v) (v is the length of
representation).
Thus,
the time complexity of the representation approach is
O(N
2
· v) on average for pair-wise sequences comparison.
75
Chapter 2.
Representation Methods for Sequence Retrieval
Figure 2.23 illustrates the execution time of di↵erent approaches in both DNA
and protein sequence datasets comparison experiments
4 5 6 7 8
.
The execution
time of Clustal-Omega is not included in this chart, as conducting a full pair-
to-pair sequence alignment process using Clustal-Omega requires many hours
for these three datasets.
Figure 2.23:
Execution time of
di↵erent approaches in sequence searching
tasks.
Comparison of representation approach to alignment programs.
Representation method shows its advantage in terms of efficiency in sequence
comparison tasks.
The efficiency of the representation method depends on the
length of
representation.
As seen in the chart,
short representation requires
less time.
For both artificial
Protein (ALF-PROT-S and ALF-PROT) se-
4
All the programs in this comparison run with multiple threads (4 threads) on a
single computer
5
Blastn:
blastn –query test.fa –db testdb –task blastn –out output –outfmt 6
–num threads 4
6
MegaBlast:
blastn –query test.fa –db testdb –task megablast –out output –
outfmt 6 –num threads 4
7
Blastp:
blastp –query genes.faa –db test –task blastp –out output –outfmt 6
–num threads 4
8
Blastp-fast:
blastp –query genes.faa –db test –task blastp-fast –out output –
outfmt 6 –num threads 4
76
Chapter 2.
Representation Methods for Sequence Retrieval
quence datasets (around 4000 to 6000 sequences), conducting full pair-to-pair
sequence similarity measurements only needs around 25 seconds on average,
which is more than 5 to 15 times faster compared to the current Blast align-
ment programs.
In the Swiss-Prot dataset,
the representation method is 10
to 20 times faster than Blast.
It is noticeable that,
in this particular ALF-
DNA dataset (including 4000 sequences), representation methods only take 2
to 4 second to complete full pairwise comparison.
our representation methods
achieve both higher accuracy and efficiency than MegaBlast.
2.8
Discussion and Conclusion
This chapter evaluates and adapts several
di↵erent representation methods
used in sequence comparison tasks.
It verifies the feasibility of
measuring
sequence similarity by calculating representation distance.
There are di↵erent
information retrieval approaches that can help us create the representations for
kmers and gene sequences.
Considering the properties of di↵erent datasets, it is
helpful to select di↵erent approaches for di↵erent datasets.
For example, in the
real-world cases utilising family information, representations can be generated
using a TF-IDF approach.
According to the results from experiments, LSH-RI
and TF-IDF methods have achieved promising results in sequence comparison
tasks.
Speed is the main advantage of
using a sequence representation to measure
similarity.
As shown in the experiments,
representation methods are faster,
even when compared to the fastest version of
Blast (MegaBlast and Blastp-
fast).
Moreover, representation methods can also achieve higher precision than
MegaBlast in DNA sequence searching.
There are still
several
improvements
that can be made to further improve the running speed of representation meth-
ods.
For instance, we can simply convert real value representations to binary
code.
Hamming distance between binary vectors can be calculated in a shorter
77
Chapter 2.
Representation Methods for Sequence Retrieval
time.
In addition, GPU computing can be utilised in the distance calculation
task.
Due to the parallel nature of graphics processing, matrix and vector op-
erations are very suitable for GPU processing, which can result in a significant
speedup.
In terms of sequence searching accuracy,
representation methods are compa-
rable and close to alignment methods in the datasets, such as Swiss-Prot and
ALF-PROT-S.
However,
in some challenging datasets (ALF-PROT),
repre-
sentation methods still show their weaknesses and need to improve compared
to the standard alignment tools (Blastn and Blastp).
It needs to be empha-
sised again that this dataset is generated with special mutation parameters in
the Alfsim,
and is designed to be challenging for both alignment based and
alignment-free approaches.
This dataset is a good sample for us to keep im-
proving the performance and finding limitations of representation methods in
this research.
In conclusion, it is necessary to seek assistance from more advanced approaches
when creating optimised representations for kmers and genes, with the help of
current big gene datasets.
In the following chapters,
machine-learning ap-
proaches
for
learning representations
for
kmers
are described.
Some gene
searching and retrieval
experiments have demonstrated that representations
learned from neural
networks can further improve searching precision.
With
additional optimisation, these approaches can potentially be used in the future
production environment.
78
Chapter 3
Neural Networks for Learning
and Improving Kmer
Representations
“Machine learning is a field of
study that
gives computers the ability to
learn without being explicitly programmed” - Arthur Lee Samuel
“Machine-learning systems are used to identify objects in images, transcribe
speech into text, match news items, posts or products with users interests,
and select relevant results of search.” - LeCun Yann, Bengio Yoshua and
Hinton Geo↵rey
3.1
Machine Learning
Machine learning underpins many aspects of modern technology,
with learn-
ing of human behaviour on the internet, identifying and labelling images, and
processing video streams to support vehicle autopilots.
In bioinformatics, the
79
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
exponential growth of the available data makes it increasingly difficult to ex-
tract useful
information from the data,
and machine learning methods are
commonly utilised [10].
Applications in genomics include the identification of regulatory elements and
noncoding RNA genes [1, 12, 17]; gene finding using a decision tree for classi-
fication and searching protein coding regions [68], and in modelling biological
networks in systems biology [41].
The performance of these machine-learning algorithms depends heavily on the
representation of the data they are given.
Each piece of information included
in the data representation is known as a feature.
Machine-learning algorithms
utilise these features to cluster or classify the pattern of objects.
The depen-
dence on representations and features is a general
phenomenon throughout
computer science.
As we have seen,
in information retrieval,
operations such
as search and collection of data can be processed faster if the collection is struc-
tured and indexed in a good format.
It is obvious that the aspect and quality
of representation has a huge e↵ect on the performance of machine learning and
searching algorithms.
Figure 3.1:
A schematic diagram of machine learning.
An overview of ma-
chine learning processes for a given task.
80
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
For many scenarios,
it is hard to identify what feature should be extracted.
For example,
in image identification tasks,
it is difficult to describe what the
object looks like in terms of pixel values.
A solution to this problem is to use
machine learning to discover the representation of
an image itself.
Learned
representations often result in much higher performance than can be obtained
with hand-designed representations [28].
Another advantage of a learning rep-
resentation is that it allows machine-learning systems to adapt quickly to new
tasks and datasets, with minimal human intervention.
In natural language processing and text mining fields, it is also commonly ac-
cepted that the success of text searching or classification results from machine-
learning algorithms is dependent on data representation.
Traditional
natural
language processing systems treat words as indices in a vocabulary,
in which
the common representation ignores the order and relationship of
words.
By
using machine-learning techniques, we may learn the representations of items,
which also preserves their relationship between each other.
In conclusion,
representation learning is a set of methods that feed raw data
to a machine-learning model to automatically discover the representations for
classification and detection.
These approaches aim at transforming the raw
input from lower levels to higher and abstract levels.
Representation learning
focused on creating representations for kmers and sequences with the help of
machine-learning techniques and existing sequence datasets in this work.
In
this chapter,
several
neural
network-based approaches are reviewed and used
to learn representations for kmers and sequences.
This review allows us to
find a deeper functional
relationship between kmers,
and increases the preci-
sion in sequence searching and retrieval,
by measuring the distance between
representations.
81
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
3.1.1
Neural Network
The history of
neural
networks began in the early 1940s,
when Warren Mc-
Culloch and Walter Pitts introduced model
of
neurological
networks which
was specifically targeted as a computational
model
of the ”nerve net” in the
brain.
[40].
In 1969, Marvin Minsky and Seymour Papert published a precise
mathematical
analysis of
the perceptron to show that the perceptron model
was not capable of representing many important problems, including a simple
XOR [47].
This research resulted in an almost complete decline in the interest
of
this research field for the next several
years.
In his dissertation in 1974,
Paul
Werbos presented a learning procedure called backpropagation of error
[89].
It was not until one decade later that this procedure became prominent.
In the late 1980s,
through the influence of
John Hopfield,
and with the (re-
)publication of backpropagation by Rumelhart, Hinton and Williams [65], the
field of
neural
networks gradually started showing influence in the machine
learning and computer science fields.
Neural network models are inspired by biological neural networks, the central
nervous systems of
animals.
The key component of
this worldview is made
out of an extensive number of interconnected components (neurones) working
cooperatively to perform a particular task [85].
An artificial
neural
network
is designed for a specific application, for example, pattern recognition or data
grouping, through a learning procedure.
82
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.2:
A schematic diagram of a neural network.
[19]
As it is shown in Figure 3.2, a neural network commonly consists of these three
functions.
1.
Propagation function.
A function that is used to transport values
through the neurons of
a neural
net’s layers.
Usually,
the input values
are added up and passed to an activation function,
which generates an
output.
2.
Activation function.
A function used to transform the activation level
of a unit (neuron) into an output signal.
3.
Output function.
Output function transfers activation to output for
the next layer.
83
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
3.1.2
Deep Learning
Deep learning has been extensively studied in recent years,
and is a part of
the machine-learning family derived from neural
networks.
In this decade,
deep learning approaches have seen major progress in solving problems where
conventional
machine-learning techniques have proven limited.
Deep learn-
ing has been applied in many scientific domains,
as it allows the discovery of
intricate structures in high-dimensional data.
Deep-learning research is partic-
ularly successful in the field of image recognition and classification.
By using
deep learning techniques,
it is feasible to learn viable feature representations
and closeness measures.
It shows exponential advantages over classic learning
algorithms that do not use distributed representations.
For instance, Learning
distributed representations enable generalization to new combinations of the
values of learned features beyond those seen during training [32].
Deep learning approaches aim at learning features at multiple levels of abstrac-
tion.
This allows a system to learn complex functions in mapping data input to
the output.
Such processes no longer depend on human-crafted features; these
can be replaced by efficient algorithms for unsupervised or semisupervised fea-
ture learning extraction.
Deep learning models are usually composed of several
learning layers.
In this work,
several
deep learning neural
networks,
such as
the autoencoder neural
network and the semantic neural
network,
have been
reviewed.
They have been successfully used in handling image recognition and
language understanding tasks.
In bioinformatics, deep learning also has been
successfully used for predicting the e↵ects of mutations in noncoding DNA on
gene expression and disease [34, 91].
In the following sections, two main neural
networks are focused on and adapted to learning the representations for kmers
and genes.
84
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
3.2
Using Neural Networks to Learn Kmer Rep-
resentations
The performance of machine learning systems is dependent on the represen-
tation of data.
Learning Representation has become an independent field in
itself within machine-learning,
which has underpinned the application of ma-
chine learning in both academia and industry [6].
Distributed representations,
were introduced in language models to solve the
problems of
high dimensionality and sparsity.
The aim of
machine learning
techniques in learning representations is to capture the functional
relation-
ships of objects in a relatively lower dimensional
real-valued continuous vec-
tor.
For example,
in natural
language,
the goal
is to capture the semantic
and syntactic properties of words.
Similar words can result in similar vectors
[61].
Distributed representations of words in a vector space help learning algo-
rithms to achieve better performance in natural language processing tasks by
grouping similar words.
One of the earliest use of word representations dates
back to 1986 [65].
Recently,
Mikolov [46]
introduced the Skip-gram model,
an efficient method for learning high quality vector representations of
words
from large amounts of unstructured text data.
Unlike most of the previously
used neural
network architectures for learning word vectors,
training of
the
Skipgram model does not involve dense matrix multiplications.
In bioinformatics, similar kmers and gene fragments may be projected into the
similar vectors if their representations can be learned from neural networks.
3.2.1
Autoencoder Neural Network
The autoencoder neural network is a prominent model to learn the representa-
tion of an input dataset.
Autoencoders are simple learning algorithms that aim
85
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
to transform inputs into outputs with the least possible amount of distortion
[87].
To address the problem of “backpropagation approaches without prepos-
itive knowledge” autoencoders were first introduced in the 1980s by Hinton
and his team [27].
More recently, autoencoders have been utilised again in the
deep-learning architecture approaches.
Autoencoder networks can be utilised
for learning features from raw input data for the purpose of
dimensionality
reduction and representation of raw data [83].
An autoencoder neural
network converts input data into di↵erent represen-
tations by the combination of encoder functions.
Decoder functions are used
to convert the representation back into the original
format.
Autoencoders
are trained to preserve as much information as possible when an input is run
through the encoder and decoder, but are also trained to make the new repre-
sentation have various nice properties.
Di↵erent kinds of autoencoders aim to
achieve di↵erent kinds of properties.
Decode Process
Decode Process
Decode Process
Decode Process
Encode Process 
Encode Process 
Encode Process 
Encode Process 
Input Data
Input Data
Reconstructed Output Data
Reconstructed Output Data
Figure 3.3:
Autoencoder neural network model
As seen in figure 3.3,
the set output (or so-called reconstructed output) is
equal
to the input [88].
A typical
autoencoder neural
network is comprised
of
two main processes:
encode and decode.
As shown in Figure 3.3,
in the
86
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
encoding process, it tries to learn the compressed representation of input data.
And in the decoding process, it attempts to decode and reconstruct the input
representation to its real
value.
Hidden layers are narrower than input and
output layers, which catch the compressed representations of the input.
After
training, each input can be reconstructed, maintaining its original properties,
but also potentially learning the whole identity of the dataset [25, 9, 77].
In the simplest case, where there is one hidden layer, an autoencoder takes the
input x and mapps onto y :
y =
1
(W x + b)
(3.1)
Here,
1
is an activation function such as a sigmoid function or a rectified
linear unit.
W refers weights between layers.
After that, y is mapped onto the
reconstruction x
0
of the same shape as x
x
0
=
2
(W
0
y + b)
(3.2)
3.2.2
Learn Kmer Representation Using Autoencoder
Neural Network
Learning kmer representations using an autoencoder neural
network can be
simply understood as a process of dimension reduction, resulting in kmer fre-
quency vectors (or other kmer representations).
A group of
kmer frequency
vectors are treated as the input entries,
which are compressed in an encoder
layer during the training process.
After the training process,
reconstructed
kmer representations can be extracted from the autoencoder neural network.
87
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
DNA sequence experiment
In this experiment, an autoencoder neural network was used to learn the rep-
resentation for each kmer.
Kmer count vectors were used as the input and
output of
the neural
network and we extracted the weights of
the encoding
hidden layer to perform as the representation of kmer.
Details of training dataset
N sequences of genes were divided into M groups, with each group containing X
genes (X = N/M).
For each kmer, its occurrence count vector was computed
for each group.
In this experiment,
I still
used the dataset ALF-DNA.
The
figure for N, M, X can be seen in the following table.
Training dataset - ALF-DNA
Kmer length
6
Number of genes (N)
3972
Number of groups (M)
20
Number of genes each group
(X)
200
(179
genes
in
last
group)
Size of kmer count vector
200
Table 3.1:
ALF-DNA Dataset for autoencoder neural network training
The structure of autoencoder neural networks is showed as below.
88
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.4:
Autoencoder neural network model for experiment.
Examples of
learning representations for AAAAAA and AAAAAC.
The representation for each kmer is grabbed from the weight between the
input layer and first encoder hidden layer.
In this case,
the length of
kmer
representation is 128.
The following precision and recall
chart compares the
representation generated from autoencoder neural network to other methods.
89
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.5:
ALF-DNA sequence retrieval
precision and recall.
Compare
kmer representations extracted from autoencoder neural network to other ap-
proaches in ALF-DNA sequence retrieval experiment.
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
Random
6mer
512
0.38
Random
6mer
1024
0.41
LSH-RI
6mer
512
0.55
LSH-RI
6mer
1024
0.57
Autoencoder
6mer
128
0.43
Autoencoder
6mer
512
0.59
Clustal
0.79
Blast
0.82
Table 3.2:
Mean average precision of representations learnt from autoencoder
neural
network.
Compare kmer representations extracted from autoencoder
neural
network to other approaches in ALF-DNA sequence retrieval
experi-
ment.
90
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
In a normal autoencoder neural network, the hidden layer is shorter than the
input layer.
As the first layer of autoencoder network used in this case consists
of 128 hidden units, the length of representation from this layer is 128.
But we
can see from Figure 3.5 and Table 3.2, even though the length of representation
is short (only 128),
the mean average precision is still
better than randomly
generated kmer representations.
Increasing the number of hidden units to 512 saw the mean average precision
in gene searching increase from 0.43 to 0.59,
overtaking that of the Random
Indexing (LSH-RI) approach.
However, in terms of the training process, it is complex and time-consuming to
learn all kmer representations from autoencoder neural networks, as every kmer
in the sequences is independently trained by a group of its occurrence count
vectors.
Alignment tools such as Blast and Clustal
still
perform more accu-
rately when measuring gene similarity.
But this experiment shows a potential
way to increase the precision of searching results by using kmer representations
learnt from gene sequence datasets.
91
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
3.2.3
Neural Probabilistic Language Model
Learn word representations in vector space
In natural
language processing techniques,
words are treated as atomic units
and represented as indices in the vocabulary list.
The N-gram model is a pop-
ular example used for statistical language modelling but this simple technique
has limits for many tasks.
Simply scaling up basic techniques may not result
in a big improvement [8].
With the progress of machine learning techniques in recent years, distributed
representations of
works based on neural
network language models have be-
come a successful approach.
In 2013,
a Google team presented new techniques for learning high-quality
word vectors from big data sets with billions of
words,
and with millions of
words in the vocabulary [46].
The results showed word representations beyond
simple syntactic regularities.
For example vector(King)
vector(M an) +
vector(W oman) resulted in a vector that was closest to the vector representa-
tion of the word Queen.
Another example is the result of a vector calculation
vec(M adrid)
vec(Spain) + vec(F rance) was closer to vec(P aris) than to
any other word vector [45, 43].
The following figure shows the representations of words in 3-dimensional space.
92
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.6:
An illustration of
Word representation in 3-dimensional
space
[46].
As shown in Figure 3.6,
vector space models represent embedded words in
a continuous vector space where semantically similar words are mapped to
nearby points.
The neural network model to discover the semantic relationship
is based on the dimensional hypothesis, which states that words appear in the
same contexts and share semantic meaning.
Googles techniques introduced
two shallow neural network models for learning word vectors [45, 44].
Figure
3.7:
The
model
architectures.
The
Continuous-Bag-of-Words
(CBOW) architecture predicts the current word based on the context,
and
the Skip-gram predicts surrounding words given the current word.
A statistical
model
of language can be represented by the conditional
proba-
bility of the next word, given all the previous ones.
93
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
P (w
1
, ..., w
t
) =
Y
t
P (w
t
|w
1
, ..., w
t
n+1
)
(3.3)
where w
t
is the t-th word.
The following figure presents an example of a neural
network model for predicting word by providing previous words.
Figure 3.8:
An example of neural network language model.
The training of
this neural
network is achieved by looking for ⇥ (weights
of
connections) that maximise the probability function or minimise the loss
function f .
f (w
t
, g(w
i
, w
i+1
, ..., w
t
1
); ⇥)
(3.4)
Function f has di↵erent forms due to the di↵erent words input format,
with
the log likelihood function being one of the common.
f =
1
T
T
X
t=1
logP (w
t
|w
t
1
, ..., w
t
n+1
))
(3.5)
The model
is trained using stochastic gradient ascent on the neural
network.
94
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
The following iterative update is performed after presenting the t-th word of
the training corpus.
⇥ = ⇥ + ✏
@f (w
t
, g(w
i
, w
i+1
, ..., w
t
1
); ⇥)
@⇥
(3.6)
There are several di↵erent tasks that can be handled by this language neural
network model, trained using a large text corpus.
First of all is word prediction.
This provides a consecutive word sequence input and predicts the next word
with maximum likelihood.
Word feature analysis is another important aspect
of this model.
In Figure 3.8, each word is connected to the neural network.
The
weights of
connections are fine-tuned through the training process,
resulting
in a representation that can be treated as a word feature vector.
Semantic
relationships between di↵erent words can be analysed by word feature vectors.
Thus, the probabilistic language neural network model is also called semantic
neural network (SNN).
These statistical
language models have already been found useful
in many
technological
applications involving natural
languages,
such as speech recog-
nition,
language translation and information retrieval.
Driven by this idea,
a
neural
network model
for learning representations of
kmers was designed in
this research.
3.2.4
Learn Kmer Representations using Neural
Net-
work
Representations of
sequences can be used in a wide range of
bioinformatics
problems, including sequence searching, family classification and sequence vi-
sualisation.
Similar to the neural
probabilistic language model,
we can also
learn the kmers representations from a neural
probabilistic language model
95
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
(SNN).
To train the neural network model using a genetic sequence dataset, we must
clearly define the tasks and goals of the learning process.
Generally speaking,
our aim is to learn the functional relationship between kmers using the neural
network.
This can be achieved by predicting central kmers by providing their
kmer neighbours.
The kmer representations extracted from this trained neural
network should be close when kmers are similar or functionally related.
To explain this objective clearly,
here is an example.
Suppose we have two
similar gene sequences as below, with only one kmer being di↵erent
1
:
Two similiar gene sequences
A B C D E X F G H I J K
A B C D E Y F G H I J K
Table 3.3:
Two similiar gene sequence.
A to K represent di↵erent kmers
It is evident that the distance between representations of
these two genes is
only determined by the distance between kmer X and kmer Y.
Distance(REP (Gene1), REP (Gene2)) = Distance(REP (X), REP (Y ))
(3.7)
Thus,
if it is possible to learn the representations for X and Y that are close
enough:
Representation(X) ⇡ Representation(Y )
(3.8)
then the whole distance between two genes can be close:
1
Or a small group of consecutive kmers is di↵erent if kmers are overlapped
96
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Representation(Gene1) ⇡ Representation(Gene2)
(3.9)
Similar to the neural
probabilistic language model,
a statistical
kmer model
can be represented by the conditional probability of the centre kmer given all
its neighbouring kmers.
P (kmer
t
) = P (k
t
|k
t
1
, k
t
2
, ..., k
t
n
, k
t+1
, k
t+2
, ..., k
t+n
)
(3.10)
P (kmer
t
) =
n
Y
i=1
P (k
t
|k
t
i
) ⇤
n
Y
t=1
P (k
t
|k
t+i
)
(3.11)
Neural network model
Considering the following sequence, each sequence can be represented as over-
lapped kmers.
A DNA Sequences
AAGCTGTGACGTGACGT
AAGCTG AGCTGT GCTGTG ...
Table 3.4:
A DNA sequence divided into 6mers for training neural network.
As per the structure of this neural
network,
there is one hidden layer.
Each
kmer in the sequence is used as the target of the neural network.
The neigh-
bours of the target kmer are treated as input entries.
As shown in Table 3.9,
the “AGCTGT” is the target of the neural
network.
Its neighbouring kmers “AAGCTG” and “GCTGTG” are the inputs of
the
neural network.
97
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.9:
Neural
network model
for learning representations of
kmers.
Input slide window size is 1.
Details of input and target format
In this model, input and target are “one-hot” vectors, which means for a given
kmer, only one out of V
2
units will be 1, and other units are 0.
Figure 3.10:
Neural network model for sequence
Kmer representations are captured from connection weight between the input
layer and hidden layer.
As we can see from Figure 3.10,
the size of represen-
tation is determined by the number of hidden units.
2
V is the number of all kmer permutation.
E.g.
For 6mer, V is 4096.
98
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Details of training process
The training of
this neural
network is achieved by looking for w (weights of
connections) that minimise the loss function f .
f (k
t
, g(k
t
1
, ..., k
t
n
, ..., k
t+1
, ..., k
t+n
); w)
(3.12)
The weights of the neural network are fine-tuned by stochastic gradient descent
[13] and back propagation [65] algorithms.
w = w + ✏
@f (k
t
, g(k
t
1
, ..., k
t
n
, ..., k
t+1
, ..., k
t+n
); w)
@w
(3.13)
Loss function f is a common mean squared error function using “one-hot”
vectors of input and output.
f =
1
2
(Output
T arget)
2
(3.14)
The Sigmoid function is used in the output layer which makes sure that output
value is between 0 and 1.
Sigmoid(t) =
1
1 + e
t
(3.15)
99
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Algorithm 4: Stochastic Gradient Descent
Input:
Maximum iterations T
begin
Set t = 0 and initial w with vector of random real number (between
-0.05 and 0.05).
for t <T do
Choose a subset of k data and compute rf (w
t
)
w
t+1
= w
t
+ ↵rf(w
t
)
t=t+1
To train this neural network on a gene sequence dataset, the sequence dataset is
divided into di↵erent subsets.
Each sequence represents one training iteration.
In one iteration,
the batch size is equal
to the number of
kmers numbers in
one sequence.
For example,
the training dataset (ALF-DNA) is 3979 DNA sequences.
The
average length of sequences is 500.
In this case, the training iteration number
is 3979 and the batch size of each epoch is 495 (6mer).
Training Details
The following figure shows the loss rate while training with ALF-DNA.
The
loss rate drops rapidly at early stages.
On average, after each training epoch,
loss rate decreases about 0.2%.
After 30 epochs, training loss rate remains at
15%.
100
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.11:
Neural network training loss rate
Evaluate Kmer representations from neural network
After training the neural network, a representation of each kmer can be gath-
ered from the weights between the input and hidden layers.
This allows us
to evaluate the representations and to see the relationship between di↵erent
kmers.
A kmeans clustering method is used to group kmers into di↵erent clus-
ters.
The following charts show the representations of the di↵erent lengths of
kmers projected to a 2-dimentional space using a PCA (Principal Component
Analysis) function.
101
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.12:
Representations of 3mers & 4mers are shown as clustered using
kmeans and projected into a 2-D space.
102
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.12 shows the cluster of
kmers (3mers and 4mers) representations
in 2-dimentional
space.
The visualisation of
kmer
representation are cre-
ated through the following steps.
First,
representation of kmers are grouped
into clusters using kmeans.
Then,
these representations are projected to 2-
dimentional space using PCA in order to show their relationship intuitively.
In this figure,
similar kmers are gathered together.
For example,
CCAC and
CACC in the blue circle are close and grouped together,
as they are highly
similar and overlapping.
It is certainly true that similar kmers are supposed
to have closer representations,
as they have more chance of appearing in the
same region of genes.
More interestingly, based on representations learnt from
this neural network, some dissimilar kmers, such as ATTG and TAAG in the
orange circle, are also very close.
This can be explained by the fact that they
may have similar kmer neighbours statistically in the sequences.
Overall, we can see from these charts that representations of overlapped kmers
are close and cluster together.
In addition, di↵erent kmers with similar neigh-
bours may have deeper relationships.
Their representations are also grouped
together from the neural network learning process.
These two charts initially
illustrate the aim achieved by this neural
network.
The functionally related
and similar kmers tend to have close representations learnt from this model.
The performance of
kmer representations can be examined in the following
sequence comparison experiments.
ALF-DNA sequence retrieval experiment
In this experiment, kmer representations learnt from the neural network were
used for DNA sequence searching.
Firstly,
an ALF-DNA dataset was used
to train the neural
network and learn the representation for each kmer.
The
following table shows the properties of the training dataset.
103
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
ALF-DNA sequences dataset for training neural network
Kmer length
5, 6, 7
Number of sequences
3972
Number of kmers in total
4375066
Number of hidden units
512, 1024
Table 3.5:
ALF-DNA sequences dataset for training neural network
Similar to previous representation approaches, we compute the whole sequence
representations using kmer representation from neural
network (See Figure
2.2).
Then,
compare sequence similarities by using sequence representations.
Precision and recall
details of
the ALF-DNA sequence searching experiment
are shown below.
This compares the performance of representations learnt by
the neural network to other approaches.
Figure 3.13:
ALF-DNA sequence retrieval
precision and recall.
Compares
kmer representations extracted from neural network to other approaches
104
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Random
6mer
512
0.38
Random
6mer
1024
0.41
LSH-RI
6mer
512
0.55
LSH-RI
6mer
1024
0.57
Autoencoder
6mer
128
0.43
Autoencoder
6mer
512
0.59
SNN
6mer
512
0.63
SNN
6mer
1024
0.64
Table 3.6:
MAP of representations learnt from a neural network.
Compares
kmer representations extracted from the neural
network to other approaches
in ALF-DNA sequence retrieval experiment.
As seen in Figure 3.13 and Table 3.6, 6mer representations learnt from SNNs
perform better than all
other approaches in sequence searching experiments.
The mean average precision of SNNs in DNA sequence searching reaches 0.64
with the length of
1024,
increasing about 4% compared to an autoencoder
neural network, and more than 7% compared to LSH approaches.
It is clear that the length of kmer also impacts on the precision of searching
results.
6mer was used in previous experiments,
which is the typical
length
of
kmer for DNA sequences.
In the following chart,
representations of
the
di↵erent lengths of kmers and alignment programs are compared in sequence
searching.
105
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.14:
ALF-DNA sequence retrieval
precision and recall.
Compare
di↵erent kmer representations extracted from neural network.
As shown in Figure 3.14,
representations perform surprisingly well
when the
length of kmer is 5.
The precision reaches 0.70 in this case, which is much better
than MegaBlast (0.41) and is close to the result of Clustal-Omega (0.79).
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
5mer
512
0.70
SNN
6mer
512
0.63
SNN
7mer
512
0.51
Clustal-Omega
0.79
MegaBlast
0.41
Blastn
0.82
Table 3.7:
MAP of representations learnt from a neural network.
Compares
kmer (with di↵erent kmer length) representations extracted from the neural
network in ALF-DNA sequence retrieval experiment.
106
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
ALF-PROT-S sequence retrieval experiment
In this section, ALF-PROT-S is used to train the neural network model.
ALF-PROT-S sequences dataset for training neural network
Kmer length
3, 4, 5, 6
Number of sequences
6359
Number of kmers in total
2484798
Number of hidden units
256, 512
Table 3.8:
ALF-PROT-S sequences dataset for neural network training
Figure 3.15:
ALF-PROT-S sequence retrieval precision and recall.
Compares
SNN representation to other representation approaches.
In this experiment, representations learnt from the SNN were used in protein
sequence retrieval.
As shown in the following figures,
the SNN representa-
tion in this task performs better than other representation approaches,
with
mean average precision achieving 0.80.
Compared to other approaches,
such
107
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
as random representations and LSH-RI methods,
protein sequence searching
precision is increased by 10% using representations learnt from semantic neural
work.
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
256
0.33
Random
3mer
512
0.36
LSH-RI
3mer
256
0.69
LSH-RI
3mer
512
0.71
SNN
3mer
256
0.79
SNN
3mer
512
0.80
Clustal-Omega
0.89
Blastp-fast
0.88
Blastp
0.94
Table 3.9:
MAP of
representations learnt from neural
network.
Compares
kmer representations extracted from neural
network to other approaches in
ALF-PROT-S sequence retrieval experiment.
We can see from the following figure that representations based on 3mers still
can achieve the best results (0.80),
which is very close to Blastp-fast (0.88)
and Clustal-Omega (0.89).
108
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Figure 3.16:
ALF-PROT-S sequence retrieval precision and recall.
Compare
SNN representation with di↵erent lengths of kmer.
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
3mer
512
0.80
SNN
4mer
512
0.62
SNN
5mer
512
0.22
SNN
6mer
512
0.20
Table 3.10:
MAP of representations learnt from neural
network.
Compare
kmer representations extracted from neural network in ALF-PROT-S sequence
retrieval experiment.
ALF-PROT sequence retrieval experiment
In this section,
the same experiments were conducted on the ALF-PROT
dataset.
109
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
ALF-PROT sequences dataset for training neural network
Kmer length
3, 4, 5, 6
Number of sequences
4000
Number of kmers in total
1396998
Number of hidden units
256, 512
Table 3.11:
ALF-PROT sequences dataset for neural network training
In this experiment, representations learnt from the SNN were used in protein
sequence retrieval.
As shown in Figure 3.17 and Table 3.12,
the SNN repre-
sentation in this task performs better than other approaches, with mean aver-
age precision achieving 0.35.
Compared to other approaches, such as random
representations and LSH-RI methods,
protein sequence searching precision is
increased by 5% to 13% using representations learnt from semantic neural
work.
Figure 3.17:
ALF-PROT sequence retrieval precision and recall.
Compares
SNN representation to other representation approaches.
110
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
Random
3mer
256
0.2239
Random
3mer
512
0.2282
LSH-RI
3mer
256
0.2916
LSH-RI
3mer
512
0.3004
SNN
3mer
256
0.3192
SNN
3mer
512
0.3519
Table 3.12:
MAP of representations learnt from neural
network.
Compares
kmer representations extracted from neural
network to other approaches in
ALF-PROT sequence retrieval experiment.
Figure 3.18:
ALF-PROT sequence retrieval
precision and recall.
Compare
SNN representation with di↵erent lengths of kmer.
111
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
3mer
512
0.35
SNN
4mer
512
0.20
SNN
5mer
512
0.26
SNN
6mer
512
0.10
Clustal-Omega
0.64
Blastp-fast
0.71
Blastp
0.93
Table 3.13:
MAP of representations learnt from neural
network.
Compare
kmer representations extracted from neural
network in ALF-PROT sequence
retrieval experiment.
Figure 3.18 and Table 3.13 indicate di↵erent lengths of kmer achieve di↵erent
precision using the neural network representation method.
On this ALF-PROT
dataset, representations of 3mers achieve 0.35 average precision in this protein
sequence retrieval
experiment.
Whereas Blastp and Blastp-fast achieve 0.93
and 0.71 average precision.
Swiss-Prot sequence retrieval experiment
The Swiss-Prot dataset was also used to evaluate the performance of
neural
network learnt representations.
Swiss-Prot sequences dataset for training neural network
Kmer length
3, 4, 5, 6
Number of sequences
5000
Number of hidden units
512
Table 3.14:
Swiss-Prot sequences dataset for neural network training
112
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Compared to other approaches, SNN representation achieves a better precision
than TF-IDF and LSH-RI,
which is close to Clustal
and Blastp-fast.
At this
stage,
SNN representation can achieve 0.69 average precision,
which is 8%
higher than TF-IDF and 34% higher than LSH-RI representations.
Figure 3.19:
Swiss-Prot sequence retrieval
precision and recall.
Compares
SNN representation using di↵erent length of kmer.
113
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
4mer
512
0.69
TFIDF
4mer
512
0.61
LSH-RI
4mer
512
0.35
Blastp
0.87
Blastp-fast
0.77
Clustal
0.78
Table 3.15:
MAP of representations learnt from a neural network.
Compares
kmer representations extracted from the neural network in Swiss-Prot sequence
retrieval experiment.
Figure 3.20:
Swiss-Prot sequence retrieval
precision and recall.
Compare
SNN representation using di↵erent length of kmer.
114
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
3mer
512
0.55
SNN
4mer
512
0.69
SNN
5mer
512
0.45
SNN
6mer
512
0.21
Table 3.16:
MAP of representations learnt from a neural network.
Compares
kmer representations extracted from the neural network in Swiss-Prot sequence
retrieval experiment.
As shown in this sequence comparison experiment,
kmer length is critical
to
the real-world dataset.
When kmer length is 4,
it reaches the best average
precision (0.69).
3.3
Discussion and Conclusion
Chapter 2 demonstrated that using representation methods to determine the
similarity of
gene sequence has speed advantages even over the fast version
of the Blast alignment programs (MegaBlast and Blastp-fast).
Chapter 3 has
focused on methods for improving representation method precision in sequence
similarity measurement tasks.
In the previous chapter,
we used LSH-RI and
TF-IDF to learn and embed the relationship between kmers and sequences, or
families,
into representations.
The probabilistic language model
described in
this chapter explores a di↵erent way and focuses on the connections between
kmers.
In DNA and protein sequence retrieval and comparison experiments, it
establishes that representation learnt from neural networks can achieve much
higher precision compared to other representation methods (LSH-RI and TF-
IDF).
115
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
The aim of
using machine-learning techniques to learn kmer and gene se-
quence representations is to capture the functional
relationships between ob-
jects (kmers).
In this chapter,
two di↵erent neural
networks (autoencoder
neural
network and neural
probabilistic language model) were reviewed and
utilised to learn representations for kmers.
The neural probabilistic language
model
is primarily discussed in this research.
Through the learning process,
and with the help of an existing sequence dataset,
the relationships between
kmers and their neighbours in a sequence are captured by the neural network.
Kmers which have the same neighbours tend to be assigned the similar and
close representations.
Due to the fact that we use the same length of
representations,
the speed
and efficiency still remain the same as described in Chapter 2 (10 to 15 times
faster than Blast).
However, using representations learnt from the neural net-
work, we have achieved a much higher precision than previous representation
approaches.
Compared to alignment programs,
for ALF-DNA dataset,
SNN
representation (based on 5mer) has achieved about 0.70 mean average preci-
sion which has been close to Clustal-Omega (0.79).
For ALF-PROT-S dataset,
SNN representation (based on 3mer) has achieved about 0.80 mean average
precision.
For the real-world Swiss-Prot datasets,
the precision of
represen-
tation (4mer) learnt from neural
networks is 0.69 which is also comparable
to alignment programs (0.77 - 0.87).
Overall,
the accuracy of representation
method using neural network has been close to alignment programs when deal-
ing with common sequence datasets.
However,
the gap between representa-
tion approaches and alignment methods is still big when dealing with protein
sequences in some special
cases,
such as more amino acid mutations in the
sequence.
The next chapter introduces the main optimisation methods used to improve
the training efficiency when learning kmer representations from a large dataset.
It will also describe the sequence partitioning strategy in representation meth-
116
Chapter 3.
Neural Networks for Learning and Improving Kmer Representations
ods to improve the precision of sequence searching results.
117
Chapter 4
Optimisation
“The action or process of making the best of something;
(also) the action
or process of
rendering optimal;
the state or condition of
being optimal.”
(From Oxford English Dictionary)
So far, we have reviewed a few di↵erent approaches for generating kmer repre-
sentations.
Of most importance is the neural network for learning representa-
tions from a sequence dataset.
As shown in the experimental results, represen-
tations learnt from a neural
network model
can achieve the highest precision
in sequence comparison,
better than all other representation approaches con-
sidered.
However, compared to popular sequence alignment programs, the accuracy of
representation methods is still
relatively low.
In this chapter,
one main opti-
misation is described, which improves the precision of representation methods
in sequence comparison.
118
Chapter 4.
Optimisation
4.1
Improve Gene Searching Precision Using
Gene Partitions
As described in previous sections,
we still
cannot achieve the same precision
as Blast and Clustal-Omega when comparing the distance between each pair
representations of the whole genes.
It is certainly true that by simply adding
all kmer representations together may introduce extra noise in sequence com-
parison.
Thus,
a sequence partitioning strategy has been used to improve precision in
this work.
Firstly,
we divided every sequence into relatively short and fixed
length partitions.
Then, we generated representation vectors for each partition
of the sequences.
Eventually, sequence similarity was determined by comparing
the partition similarity between each pair sequences.
Figure 4.1:
Improve searching precision by dividing gene sequence into par-
titions.
4.1.1
Gene Searching Experiments Using Partitioning
Approach
ALF-DNA sequences dataset
For the ALF-DNA dataset,
each sequence was divided into small
partitions
(length l=32) with the overlap of 16.
The DNA sequence searching results are
119
Chapter 4.
Optimisation
shown in Figure 4.2 and Table 4.1.
Using a representation method for the whole
sequence we can achieve 0.69 mean average precision.
By dividing the sequence
into small
partitions (length 32),
and using the same kmer representations
learnt from the SNN, the mean average precision increases to 0.83, which has
overtaken the precision of Blastn and Clustal-Omega.
Figure 4.2:
ALF-DNA sequence retrieval precision and recall.
Using partition
method to improve precision of
representation method.
Divide every DNA
sequence into 32 length of partitions with 16 length overlapped.
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
Clustal-Omega
0.79
Blastn
0.82
SNN
5mer
512
0.69
SNN (Partition)
5mer
512
0.83
Table 4.1:
MAP of representations learnt from neural network with optimi-
sation in ALF-DNA sequence retrieval experiment.
120
Chapter 4.
Optimisation
Swiss-Prot sequences dataset
In the real-world dataset Swiss-Prot,
the sequence partitioning method can
increase average precision by 10% using the same kmer representations.
The
results show that precision has now overtaken Blastp-fast and Clustal.
Figure 4.3:
Swiss-Prot sequence retrieval precision and recall.
Using partition
method to improve precision of representation method.
Divide every protein
sequence into partitions (length 32)
Mean average precision
Representation
Method
Kmer length
Representation
length
MAP
Blastp
0.87
Blastp-fast
0.77
Clustal
0.78
SNN
4mer
512
0.69
SNN (Partition)
4mer
512
0.81
Table 4.2:
MAP of representations learnt from neural network with optimi-
sation in Swiss-prot sequence retrieval experiment.
121
Chapter 4.
Optimisation
By dividing a sequence into partitions or blocks, precision is improved because
highly similar regions can be identified by their representations.
However, this
method has its limitations.
First of
all,
the distance measurement between
partitions instead of between whole gene sequences introduces additional
ex-
ecution time.
Secondly,
the size of
the partition is critical
to the precision
achieved.
The figure may be decreased by longer or shorter partitions.
Based
on this research,
the size of
partition between 24 (protein sequence) to 32
(DNA sequence) is an appropriate length to improve comparison performance.
4.2
Discussion and Conclusion
In this chapter, a main optimisation method has been been described.
These
were used to improve the accuracy of
sequence searching results.
Sequence
partitioning was an optimisation method used in this research, which aimed at
increasing the search precision by dividing sequences into di↵erent overlapped
partitions.
As shown in results from previous experiments,
average precision
can be increased by 5% to 10% using a partitioning method.
122
Chapter 5
Future work and Conclusions
5.1
Future Work
This thesis has demonstrated the potential of utilising representation approachebased
on information retrieval and natural language processing in sequence compari-
son tasks.
Di↵erent methods of creating kmer and sequence representations for
the sequence comparison purpose have been described and compared.
There
are many other opportunities for extending the scope of this work.
This section
presents some of these directions.
5.1.1
Accelerate Neural
Network Model
Using Hierar-
chical Softmax
In the previous chapters,
a neural
network model
designed for learning kmer
and sequence representation was described.
However,
the training process
takes a long time, even when using a small dataset.
Based on the description
of
the neural
network model
in the previous section,
the bottleneck of
the
neural
network implementation is the connections between the hidden layer
123
Chapter 5.
Future work and Conclusions
and the output layer.
It can be shown in the following figure that if we use the
“one-hot” vector as input in this neural network, only one unit of each input is
actively connecting to the hidden units, no matter what the size of the input
vector.
Figure 5.1:
Neural network model.
Input layer and hidden layer
However, the situation becomes complicated when computations move to the
output layer.
Figure 5.2 shows that the units in the output layer and units in
the hidden layer are fully connected, and the number of connections increases
dramatically when the size of the output vector and size of the hidden units
increase (Table 5.1).
Figure 5.2:
Neural network model.
Output layer and hidden layer
We can see from Table 5.1 that to learn the length of 512 representation for
6mers,
the number of connections between the hidden layer and output layer
124
Chapter 5.
Future work and Conclusions
Number of connections between hidden and output layer
Kmer
length
Size of one-
hot vector
Hidden
layer size
Connections
between
hid-
den layer and output layer
3mer
64
256
16384
4mer
256
256
65536
5mer
1024
256
262144
6mer
4096
256
1048576
3mer
64
512
32786
4mer
256
512
131072
5mer
1024
512
524288
6mer
4096
512
2609152
Table 5.1:
Number of connections between hidden and output layer for dif-
ferent kmer and di↵erent size of hidden layer
increase to 2609152, which means it is required to update more that 2 million
connection weights in this neural network for each training iteration.
To solve this problem, Hierarchical Softmax techniques can be used in this work
to decrease computational
complexity.
Hierarchical
Softmax (or hierarchical
decomposition) uses a binary tree model
to optimise the target value of
the
neural network model [8].
The process of
hierarchical
softmax can be explained as a series of
binary
stochastic decision associated with nodes of a binary tree [50].
In hierarchical
softmax, each target kmer corresponds to a leaf of a binary tree.
Each node of
the tree is indexed by a bit vector corresponding to the path from the root to
the node.
The encoding of for the node from the root to the leaf can represent
each kmer.
125
Chapter 5.
Future work and Conclusions
Figure 5.3:
Hierarchical
softmax using binary tree.
The path from root to
each leaf represent each kmer.
In the hierarchical
softmax model,
the probability of
output kmer is repre-
sented as the combination of the probability of each unit from the root to the
kmer node in the binary tree model.
Thus, instead of computing the probabil-
ity of each kmer in the output layer,
we can simply compute the probability
of unit to find target kmer on the tree path.
It is noticeable that if the tree is the balanced binary tree, then the maximum
length of
bit vector for kmer is log
2
(V ) (V represents the total
number of
individual
kmers in the sequence).
Apparently,
time complexity decreases
from O(V ) to O(log
2
(V )).
For example,
with the size of
kmers used in our
experiments, |V | = 4096 so log
2
|V | = 12.
Using a Hierarchical
Softmax approach to create a unique bit code for each
target kmer in the neural
network theoretically shorten the training time by
reducing the number of connections between the hidden layer and output layer.
This approach can be considered in this research in the future.
5.1.2
Signatures - Binary Representations
In information retrieval, signatures are short binary strings, representing text
documents and other searchable objects in a search engine.
TopSig,
a topol-
126
Chapter 5.
Future work and Conclusions
ogy preserving document signature method [26]
introduced a new approach
to constructing document signatures,
which built upon and extended LSH.
It demonstrated a significant improvement in performance for searching and
clustering tasks.
In this work, gene sequence similarity was measured by calculating the distance
between representations of genes,
so binary representations (signatures) have
natural advantages.
First, binary vectors may be easily represented and require
much less storage than text.
Moreover, the Hamming distance between binary
codes can be rapidly computed in hardware [56].
Due to all these facts, it would be desirable to utilise binary representations in
gene searching problems.
In this research, a simple experiment was conducted
by converting the representations learnt from the neural
network to binary
representations.
The following chart shows precision and recall results of using
signatures in an ALF-PROT-S sequence searching task.
Figure 5.4:
ALF-PROT-S sequence retrieval
precision and recall.
Using
binary representations (signatures) converted from real valued representations.
127
Chapter 5.
Future work and Conclusions
Mean Average Precision
Representation
Method
Kmer length
Representation
length
MAP
SNN
3mer
512
0.80
SNN-Binary
3mer
512
0.77
SNN
3mer
1024
0.81
SNN-Binary
3mer
1024
0.78
SNN
3mer
2048
0.80
SNN-Binary
3mer
2048
0.79
Table 5.2:
MAP of signatures converted from SNN representation in ALF-
PROT-S sequence retrieval experiment.
As shown in Figure 5.4 and Table 5.2,
mean average precision drops by 3%
when short representations (512 length) are converted to binary representa-
tions.
If we convert long representations (1024 length) to signatures, mean av-
erage precision still remains at the same value.
This experiment illustrates that
longer signatures (1024 to 4096 length) can achieve the same performance as
real valued representations in sequence comparison and retrieval tasks.
More-
over, a significant advantage of using signatures is that by using the Hamming
distance, the processing time can be dramatically shortened.
This was only a preliminary experiment in generating signatures for genes.
Other potential
methods for sequence signature creation may also achieve a
better result in sequence searching tasks.
The semantic hashing [67] approach
uses a Restricted Boltzmann Machine (RBM) to learn one layer of hidden vari-
ables, mapping the original text object from a word count vector to the binary
vector representations.
By using this method,
a higher accuracy has been
achieved than applying TF-IDF to the entire document set.
This approach
might be feasible for genetic sequence data.
128
Chapter 5.
Future work and Conclusions
5.1.3
Sequence Family Classification
Sequence comparison was the main task in this experiment.
By conducting
sequence retrieval and comparison experiments, representation methods could
be compared to alignment methods, such as Blast and Clustal.
Classifying and
determining the families of sequences is another important topic in bioinfor-
matics.
The Swiss-Prot dataset has manually labelled annotation with family
information.
Thus, this dataset can be used to train a machine-learning model
for sequence family classification.
In this section,
the SNN sequence repre-
sentation is used by a support vector machine in a Swiss-Prot classification
experiment.
A Support Vector Machine (SVM) is a supervised learning model for classifica-
tion (and regression analysis), which is formally defined by a constrained sep-
arating hyperplane.
When given labelled training data (supervised learning),
the algorithm outputs an optimal
hyperplane that categorises new examples.
Support vectors define the boundary of the class examples and the SVM model
maps data points into separate categories divided by an optimally chosen gap
[21].
The SVM has achieved highly accurate results in many di↵erent data
classification tasks.
This experiment measured the quality and performance of
sequence repre-
sentation learnt from SNN in family classification tasks.
It compared kmer
frequency vector (KCV) and kmer TF-IDF vectors.
Figure 5.5 indicates preci-
sion and recall curves for the di↵erent type of sequence representations in the
classification task.
129
Chapter 5.
Future work and Conclusions
Figure 5.5:
ALF-Prot sequences family classification using SVM.
Compare
sequences SNN representation to KCV and TF-IDF representation.
Sequence Family Classification
Representation Method
Avg Precision
Avg Recall
Kmer Count Vector (KCV)
0.64
0.69
Kmer TF-IDF vector
0.91
0.87
SNN-3mer-512
0.96
0.92
Table 5.3:
Evaluation of Sequence Family Classification.
Kmer frequency vector and TF-IDF vector are common ways to represent a
sequence for classification and clustering purpose.
It is shown in Figure 5.5,
in this sequence classification experiment, KCV and TF-IDF achieve 0.64 and
0.91 average precision.
In contrast,
representation from neural
network can
reach 0.96 average precision.
This is just a preliminary experiment regarding the gene sequence family classi-
130
Chapter 5.
Future work and Conclusions
fication using SVM and representation learnt from SNN. We still can not make
the conclusion that this method can outperform other sequence classification
approaches.
The relevant research can be conducted in the future.
5.1.4
Parallel Computing
In this research, we have implemented multiple threads process in the programs
for neural
network training and representation distance calculation.
These
parallel processes can certainly be improved in the continuing work.
GPU (Graphics processing unit) computing uses graphics processing units to
do general scientific and engineering computing.
Due to the massively parallel
architecture of GPU, computationally intensive assignments can be completed
much faster compared with conventional
CPUs.
This is why GPU comput-
ing has enormous potential,
particularly in areas where data and computer-
intensive basic research requires the processing of
large volumes of
measure-
ment data.
There have been many research and implementations of
using GPU in neu-
ral
network training.
The following figure compares the execution time and
corresponding speedup of a neural
network training between CPU and GPU
[76].
131
Chapter 5.
Future work and Conclusions
Figure 5.6:
Execution time (a) and corresponding speedup (b) of the three
di↵erent implementations performing 1,000 learning iterations of a neural net-
work.
CP U
triv
represents an implementation without any manual parallelization or
vectorization.
CP U
opt
is an optimised implementation using functions from
Intels Performance Libraries IPP (Integrated Performance Primitives ) and
MKL (Math Kernel Library) [76].
As seen from this figure, the training process
can get a speedup of 200% to 2400% using GPU.
In this work,
sequences were represented by real
valued vectors.
Processes
and tasks towards these representation vectors, such as distance calculations,
could also be implemented in a GPU computing framework.
In the next step
of this work,
a longer representation may be created for each sequence,
per-
haps allowing us to achieve higher searching precision.
With the help of GPU
computing, a higher speed of sequence similarity comparison processes might
be achieved, now and in the future.
132
Chapter 5.
Future work and Conclusions
5.2
Conclusions
This work concentrated on the representation methods for sequence compari-
son.
We have near-exhaustively analysed and discussed the feasibility of using
representation methods in sequence searching and comparison problems.
To
generate a representation of kmer and sequence for comparison purpose,
dif-
ferent methods from information retrieval
such as Locality-Sensitive Hashing
(reflective random indexing) and TF-IDF methods have been reviewed.
More-
over, a probabilistic language neural network model was explored in consider-
able detail
in this research.
This model
tries to learn the kmer relationships
and generate representations from existing dataset.
All these approaches have
been evaluated on both artificial
and real-world sequence datasets and com-
pared with common alignment approaches in terms of accuracy and efficiency.
This section provides a summary of the whole thesis and the conclusion of this
research.
5.2.1
Summary of the Research
Alignment approaches for sequence comparison
In Chapter 1, some background was provided on molecular biology and bioin-
formatics.
We briefly looked at the theories and algorithms of di↵erent align-
ment methods.
In this chapter, three di↵erent genetic sequence datasets were
also introduced,
which were used throughout this research.
Based on these
datasets,
sequence comparison experiments were conducted using alignment
programs; results from which were treated as the benchmark and compared to
the representation methods in the succeeding chapters.
133
Chapter 5.
Future work and Conclusions
Representation methods for sequence comparison
Chapter 2 discussed the models and processes of representation methods used
in sequence comparison.
It demonstrated the feasibility of
using representa-
tions of kmers and sequences,
and three di↵erent approaches:
random repre-
sentation, locality-sensitive hashing (reflective random indexing) and TF-IDF
were discussed and reviewed.
This chapter also compared their accuracy and
efficiency with common alignment programs.
Experimental results showed that
in sequence comparison tasks (4000 to 6000 pairwise sequences comparison),
representation approaches were 10 to 15 times faster on average than alignment
programs,
although precision remained lower than alignment programs.
But
there was a path to improve precision by utilising information from the current
dataset and by learning the relationships between kmers and sequences.
Learning representations using neural network from sequence dataset
Chapter 3 investigated machine learning methods,
especially neural
network
models for kmer representation learning purposes.
In this research,
a prob-
abilistic language neural
network model
was investigated.
By learning and
embedding kmer relationships into their representations, experimental results
indicated that representations learnt from neural
networks improved the se-
quence comparison precision by 5% to 25% compared to other representation
methods in all three datasets.
These precision results have also been close to
alignment programs in the real-world sequence dataset.
Optimisations
Chapter 4 described the two main optimisations used in this research.
Using
Hierarchical
Softmax,
we could significantly improve the efficiency of
neural
network training processes.
The whole training process time was reduced from
134
Chapter 5.
Future work and Conclusions
hours to minutes.
Moreover, to further improve the precision of sequence com-
parison with representation methods, we used a sequence partitioning method
in this research.
Eventually,
the final
precision overtook that of
alignment
programs, such as Clustal-Omega and the fast version of Blast.
5.2.2
Conclusion
The development of
NGS technologies has seen a dramatic increase in the
speed of sequence production, with the newest machines producing as much as
100 GB per day.
However,
increased data availability poses many challenges
to current computational techniques.
Sequence comparison and similarity measurement is a central task in compu-
tational biology; an important step in understanding functional, structural, or
evolutionary relationships between the sequences.
Alignment-based methods
have been successfully utilised in sequencing production environments,
but
these approaches may not scale to very large datasets,
with time complex-
ity quadratic in the sequence length.
Sequence alignment may also perform
poorly if there is structural
re-arrangement of the sequence,
rather than just
local
substitutions,
insertions and deletions.
Thus,
many studies have exam-
ined new approaches to sequence similarity,
with alignment-free methods a
major theme.
This work has substantially discussed and investigated the feasibility of repre-
sentation methods based on kmers for sequence comparison.
As can be seen
from this research, a great advantage of this approach is its efficiency, with the
speed of pair-wise sequence comparison as much as 10 to 15 times faster than
common alignment programs.
To generate a representation of kmers and sequences, di↵erent approaches such
as Reflective Random Indexing (LSH-RI) and TF-IDF have been reviewed and
135
Chapter 5.
Future work and Conclusions
compared.
Moreover, to further improve sequence comparison accuracy, a neu-
ral
network based probabilistic language model
has been investigated in this
research.
The main outcomes from the resulting experiments showed that
representations learnt by neural
networks further improved precision by 5%
to 25% compared to other representation methods in the sequence searching
and retrieval tasks, producing results comparable to commonly used alignment
tools such as Blast and Clustal.
With the help of
the sequence partitioning
approach from chapter 4,
precision was superior to that of
some alignment
programs (Clustal-Omega,
Blastp and MegaBlast) on the real-world dataset
(Swiss-Prot), though this requires significant additional computation.
To sup-
port the theories provided in the thesis,
a collection of programs and scripts
for representation learning and sequence comparison have been implemented
and made available.
This research starts from the theory and extends to specific software develop-
ment.
It o↵ers new ideas for the use of machine learning in sequence searching
problems and in understanding the pattern and structure of genetic data, and
has identified promising directions for future research to improve the efficiency
and accuracy of representation methods for sequence comparison.
136
Chapter 6
Appendices
6.1
Main Programs Implementation
Several di↵erent programs and scripts have been developed for gene sequences
processing, kmer representation learning and neural network training over the
course of the research programme.
These programs and scripts were mainly
developed in C++ and Python.
Three main modules of the program in C++
are discussed in this section, including the neural network for kmer represen-
tation learning and gene sequence similarity measurement.
All programs were
implemented to allow multi-thread processing.
Utility module
Utils.hpp was the main head file used in SemanticNeuralNetwork and Gene-
SigDistance, which included some helper functions, such as file handling func-
tions, string processing functions and math functions.
Neural
network module
The neural
network described in this research has been implemented from
137
Chapter 6.
Appendices
scratch.
The program included 2 main files, SemanticNeuralNetwork.hpp and
SemanticNeuralNetwork.cpp.
Parallel processing (multi-threading) was imple-
mented in this program).
Compile Command
icc
SemanticNeuralNetwork.cpp -o
SemanticNeuralNetwork
-Ofast
-
pthread -std=c++11
Usage Command
./SemanticNeuralNetwork all.fa 6 30
Learn representations for 6mer from sequence file in 30 thread.
Sequence similarity comparison module
This program was used for gene sequence similarity comparison by combining
kmer representation for genes and calculating the distance between each pair
of gene representations.
Parallel processing was again supported.
Compile Command
icc
GeneSigDistance.cpp
-o
GeneSigDistance
-Ofast
-pthread
-
std=c++11
Usage Command
./GeneSigDistance rep-file all.fa 30
Calculate similairty scores for each pair genes based on kmer representa-
tion files in 30 threads
Other Scripts
RIGenes.cpp
138
Chapter 6.
Appendices
Create reflective random indexing representation for kmers from se-
quence dataset.
tfidf-sig.py
Create TF-IDF representation for kmers from sequence dataset.
gene sig create.py
Create gene sequence representation from kmer representations.
gene distance score.py
Measure gene sequence similarity score and distance based on their rep-
resentation distance.
kmeans-scipy.py
Clustering and plot kmers representations using PCA and Kmeans.
svm.py
Gene sequence family classification using SVM training machine.
svm-roc-pr.py
Receiver operating characteristic and Precision-Recall measurement for
sequence family classification using SVM.
The source codes and scripts of programs listed in this section can be found
here:
https://github.com/vvilp/GenomeKit
139
Chapter 6.
Appendices
6.2
Third Party Programs
In this section, third party programs and tools used in this work are listed.
Blast family sequence alignment programs
BLAST+(2.4.0) includes Blastn for nucleotide sequences and Blastp for protein
sequences.
https://blast.ncbi.nlm.nih.gov
Clustal-Omega
Clustal Omega (1.2.2) is the latest addition to the Clustal multiple alignment
tool family.
http://www.clustal.org/omega/
Alfsim
ALF simulates a root genome into a number of related genomes.
Result files
include the resulting gene sequences, true tree and true MSAs [22].
http://alfsim.org/
Scikit-learn
Scikit-learn is a machine learning tool library in python.
http://scikit-learn.org/
Gensim
Gensim is a software framework for Topic Modelling with Large Corpora [62].
https://radimrehurek.com/gensim/
140
Chapter 6.
Appendices
trec eval
trec eval is the standard tool used by the TREC community for evaluating an
ad hoc retrieval run, given the results file and a standard set of judged results.
http://trec.nist.gov/trec eval/
141
Bibliography
[1]
Aerts,
S.,
Van Loo,
P.,
Moreau,
Y.,
and De Moor,
B.
A ge-
netic algorithm for the detection of new cis-regulatory modules in sets of
coregulated genes.
Bioinformatics 20, 12 (2004), 1974–1976.
[2]
Aizawa, A.
An information-theoretic perspective of tf-idf measures.
In-
formation Processing and Management 39, 1 (2003), 45–65.
[3]
Altschul, S. F., Gish, W., Miller, W., Myers, E. W., and Lip-
man,
D.
J.
Basic local
alignment search tool.
Journal
of
Molecular
Biology 215, 3 (1990), 403–10.
[4]
Baeza-Yates,
R.,
and Ribeiro-Neto,
B.
Modern information re-
trieval.
New York 9 (1999), 513.
[5]
Bairoch, A., and Apweiler, R. The SWISS-PROT protein sequence
database and its supplement TrEMBL in 2000.
Nucleic Acids Research
28, 1 (2000), 45–48.
[6]
Bengio, Y.
Deep learning of representations:
Looking forward.
Lecture
Notes in Computer Science (including subseries Lecture Notes in Artificial
Intelligence and Lecture Notes in Bioinformatics) 7978 LNAI
(2013), 1–
37.
142
Bibliography
[7]
Bengio, Y., Courville, A., and Vincent, P.
Representation learn-
ing:
A review and new perspectives. IEEE Transactions on Pattern Anal-
ysis and Machine Intelligence 35, 8 (2013), 1798–1828.
[8]
Bengio, Y., Ducharme, R., Vincent, P., and Janvin, C. A Neural
Probabilistic Language Model. The Journal of Machine Learning Research
3 (2003), 1137–1155.
[9]
Betechuoh,
B.
L.,
Marwala,
T.,
and Tettey,
T.
Autoencoder
networks for HIV classification. Current Science 91, 11 (2006), 1467–1473.
[10]
Bishop, C. M. Pattern Recognition and Machine Learning, vol. 4.
2006.
[11]
Blackshields, G., Sievers, F., Shi, W., Wilm, A., and Higgins,
D. G. Sequence embedding for fast construction of guide trees for multiple
sequence alignment.
Algorithms for molecular biology :
AMB 5 (2010),
21.
[12]
Bockhorst, J., Craven, M., Page, D., Shavlik, J., and Glasner,
J. A bayesian network approach to operon prediction.
Bioinformatics 19,
10 (2003), 1227–1235.
[13]
Bottou, L.
Stochastic Learning.
Learning (2003), 22.
[14]
Camacho, C., Coulouris, G., Avagyan, V., Ma, N., Papadopou-
los, J., Bealer, K., and Madden, T. L. BLAST+:
architecture and
applications.
BMC bioinformatics 10 (2009), 421.
[15]
Can,
T.
Introduction to bioinformatics.
Methods in Molecular Biology
1107 (2014), 51–71.
[16]
Carr, P. a., and Church, G. M. Genome engineering. Nature biotech-
nology 27, 12 (2009), 1151–1162.
143
Bibliography
[17]
Carter, R. J., Dubchak, I., and Holbrook, S. R. A computational
approach to identify genes for functional
RNAs in genomic sequences.
Nucleic acids research 29, 19 (2001), 3928–38.
[18]
Chenna, R., Sugawara, H., Koike, T., Lopez, R., Gibson, T. J.,
Higgins,
D. G.,
and Thompson,
J. D.
Multiple sequence alignment
with the Clustal series of programs. Nucleic Acids Research 31, 13 (2003),
3497–3500.
[19]
Clarkson,
T.
G.
Introduction to neural
networks.
Neural
Network
World 6, 2 (1996), 123–130.
[20]
Corpet,
F.
Multiple sequence alignment with hierarchical
clustering.
Nucleic acids research 16, 22 (1988), 10881–10890.
[21]
Cortes, C., and Vapnik, V. Support vector machine. Machine learning
(1995), 1303–1308.
[22]
Dalquen, D. A., Anisimova, M., Gonnet, G. H., and Dessimoz,
C. ALF-A simulation framework for genome evolution. Molecular Biology
and Evolution 29, 4 (2012), 1115–1123.
[23]
Dasgupta,
A.,
Kumar,
R.,
and Sarlos,
T.
Fast locality-sensitive
hashing.
Proceedings of the 17th ACM SIGKDD international
conference
on Knowledge discovery and data mining - KDD ’11 (2011), 1073.
[24]
Donyai,
P.
Information retrieval.
Information Retrieval
4,
2 (2009),
1–13.
[25]
Germain,
M.,
Gregor,
K.,
Murray,
I.,
Larochelle,
H.,
Ed,
I.
M.,
and Uk,
A.
C.
MADE:
Masked Autoencoder for Distribution
Estimation.
Proceedings of
The 32nd International
Conference on Ma-
chine Learning 37 (2015), 881–889.
144
Bibliography
[26]
Geva,
S.
TOPSIG:
topology preserving document signatures.
Proceed-
ings of the 20th ACM international, October (2011), 1–12.
[27]
Hinton,
G. E.
Reducing the Dimensionality of Data with Neural
Net-
works.
Science 313, 5786 (2006), 504–507.
[28]
Hinton, G. E.
Learning multiple layers of representation, 2007.
[29]
Hirschberg,
D.
S.
A linear space algorithm for computing maximal
common subsequences.
Communications of the ACM 18,
6 (1975),
341–
343.
[30]
Katoh, K., and Toh, H.
PartTree:
An algorithm to build an approx-
imate tree from a large number of
unaligned sequences.
Bioinformatics
23, 3 (2007), 372–374.
[31]
Larkin,
M.
A.,
Blackshields,
G.,
Brown,
N.
P.,
Chenna,
R.,
Mcgettigan,
P.
A.,
McWilliam,
H.,
Valentin,
F.,
Wallace,
I. M., Wilm, A., Lopez, R., Thompson, J. D., Gibson, T. J., and
Higgins,
D.
G.
Clustal
W and Clustal
X version 2.0.
Bioinformatics
23, 21 (2007), 2947–2948.
[32]
LeCun, Y., Bengio, Y., and Hinton, G. Deep learning.
Nature 521,
7553 (2015), 436–444.
[33]
Leimeister,
C.
A.,
Boden,
M.,
Horwege,
S.,
Lindner,
S.,
and
Morgenstern,
B.
Fast
alignment-free
sequence
comparison using
spaced-word frequencies.
Bioinformatics 30, 14 (2014), 1991–1999.
[34]
Leung,
M.
K.
K.,
Xiong,
H.
Y.,
Lee,
L.
J.,
and Frey,
B.
J.
Deep learning of the tissue-regulated splicing code.
Bioinformatics 30, 12
(2014).
145
Bibliography
[35]
Li, P., and Goldman, N. Models of molecular evolution and phylogeny.
Genome research 8, 12 (1998), 1233–1244.
[36]
Li, W., Fu, L., Niu, B., Wu, S., and Wooley, J. Ultrafast clustering
algorithms for metagenomic sequence analysis.
Briefings in Bioinformat-
ics 13, 6 (2012), 656–668.
[37]
Lipman,
D.
J.,
and Pearson,
W.
R.
Rapid and sensitive protein
similarity searches.
Science 227, 4693 (1985), 1435–1441.
[38]
Manning, C. D., and Raghavan, P.
An Introduction to Information
Retrieval, vol. 1.
2009.
[39]
Maxam, a. M., and Gilbert, W. A new method for sequencing DNA.
Proceedings of the National
Academy of Sciences of the United States of
America 74, 2 (1977), 560–564.
[40]
McCulloch,
W.
S.,
and Pitts,
W.
A Logical
Calculus of the Idea
Immanent in Nervous Activity.
Bulletin of
Mathematical
Biophysics 5
(1943), 115–133.
[41]
Mendes,
P.,
Hoops,
S.,
Sahle,
S.,
Gauges,
R.,
Dada,
J.,
and
Kummer,
U.
Computational
modeling of
biochemical
networks using
COPASI.
Methods In Molecular Biology Clifton Nj 500 (2009), 17–59.
[42]
Metzker, M. L. Sequencing technologies - the next generation.
Nature
reviews. Genetics 11, 1 (2010), 31–46.
[43]
Mikolov,
T.,
Chen,
K.,
Corrado,
G.,
and Dean,
J.
Distributed
Representations of Words and Phrases and their Compositionality.
Nips
(2013), 1–9.
[44]
Mikolov, T., Corrado, G., Chen, K., and Dean, J.
Efficient Es-
timation of Word Representations in Vector Space.
Proceedings of the In-
146
Bibliography
ternational Conference on Learning Representations (ICLR 2013) (2013),
1–12.
[45]
Mikolov,
T.,
Kopeck
´
y,
J.,
Burget,
L.,
Glembek,
O.,
and
ˇ
Cernock
´
y,
J.
H.
Neural
network based language models for highly
inflective languages.
ICASSP, IEEE International
Conference on Acous-
tics, Speech and Signal
Processing - Proceedings (2009), 4725–4728.
[46]
Mikolov,
T.,
Yih,
W.-t.,
and Zweig,
G.
Linguistic regularities in
continuous space word representations. Proceedings of NAACL-HLT, June
(2013), 746–751.
[47]
Minsky, M., and Papert, S. Perceptrons:
An Introduction to Compu-
tational
Geometry, vol. 1988.
1969.
[48]
Moore, J. H.
Bioinformatics, 2007.
[49]
Moreno-S
´
anchez, I., Font-Clos, F., and Corral,
´
A. Large-scale
analysis of Zipf’s law in English texts.
PLoS ONE 11, 1 (2016).
[50]
Morin, F., and Bengio, Y.
Hierarchical probabilistic neural network
language model.
Proceedings of
the Tenth International
Workshop on
Artificial
Intelligence and Statistics (2005), 246–252.
[51]
Mount,
D.
W.
D.,
W.Mount,
D.,
and Mount,
D.
W.
D.
Bioin-
formatics:
Sequence and Genome Analysis.
Annals of Physics 54 (2004),
565.
[52]
Navarro,
G.
A guided tour to approximate string matching.
ACM
Computing Surveys 33, 1 (2001), 31–88.
[53]
Needleman, S. B., and Wunsch, C. D. A general method applicable
to the search for similarities in the amino acid sequence of two proteins.
Journal
of Molecular Biology 48, 3 (1970), 443–453.
147
Bibliography
[54]
Ondov,
B.
D.,
Treangen,
T.
J.,
Mallonee,
A.
B.,
Bergman,
N.
H.,
Koren,
S.,
and Phillippy,
A.
M.
Fast
genome
and
metagenome distance estimation using MinHash.
bioRxiv (2015), 029827.
[55]
Paltoglou, G., and Thelwall, M. A study of Information Retrieval
weighting schemes for sentiment analysis.
In Proceedings of the 48th An-
nual
Meeting of
the Association for Computational
Linguistics
(2010),
no. July, pp. 1386–1395.
[56]
Pappalardo, F., Calonaci, C., Pennisi, M., Mastriani, E., and
Motta,
S.
HAMFAST:
Fast hamming distance computation.
In 2009
WRI World Congress on Computer Science and Information Engineering,
CSIE 2009 (2009), vol. 1, pp. 569–572.
[57]
Pearson, W., and Lipman, D. Improved tools for biological sequence
comparison.
Proceedings
of
the National
Academy of
Sciences
of
the
United States of America 85, 8 (1988), 2444–2448.
[58]
Piantadosi,
S.
T.
Zipf’s word frequency law in natural
language:
a
critical review and future directions.
Psychonomic bulletin \& review 21,
5 (2014), 1112—-1130.
[59]
Powers, D.
Evaluation:
from precision,
recall and F-measure to ROC,
informedness,
markedness and correlation.
Journal
of Machine Learning
Technologies 2, 1 (2011), 37–63.
[60]
Ramos, J., Eden, J., and Edu, R. Using TF-IDF to Determine Word
Relevance in Document Queries.
Processing (2003).
[61]
Ratinov,
L.,
and Turian,
J.
Word representations :
A simple and
general method for semi-supervised learning.
Acl, July (2010), 384–394.
[62]
ˇ
Reh
˚
u
ˇ
rek, R., and Sojka, P. Software Framework for Topic Modelling
with Large Corpora.
In Proceedings of the LREC 2010 Workshop on New
148
Bibliography
Challenges for NLP Frameworks
(Valletta,
Malta,
May 2010),
ELRA,
pp. 45–50.
[63]
Reis-Filho, J. S.
Next-generation sequencing.
Breast cancer research :
BCR 11 Suppl
3 (2009), S12.
[64]
Robertson, S. Understanding inverse document frequency:
on theoret-
ical arguments for IDF.
Journal
of Documentation 60, 5 (2004), 503–520.
[65]
Rumelhart, D. E., Hinton, G. E., and Williams, R. J.
Learning
representations by back-propagating errors. Nature 323, 6088 (1986), 533–
536.
[66]
Sahlgren, M. An Introduction to Random Indexing.
Proceedings of the
Methods and Applications of Semantic Indexing Workshop at the 7th In-
ternational Conference on Terminology and Knowledge Engineering, TKE
2005 (2005), 1–9.
[67]
Salakhutdinov, R., and Hinton, G. Semantic hashing. International
Journal
of Approximate Reasoning 50, 7 (2009), 969–978.
[68]
Salzberg,
S.
Locating protein coding regions in human DNA using a
decision tree algorithm.
Journal
of
computational
biology :
a journal
of
computational
molecular cell
biology 2, 3 (1995), 473–85.
[69]
Sanger,
F.,
and Coulson,
A.
R.
A rapid method for determining
sequences in DNA by primed synthesis with DNA polymerase.
Journal of
Molecular Biology 94, 3 (1975).
[70]
Sanger,
F.,
Nicklen,
S.,
and Coulson,
a.
R.
DNA sequencing
with chain-terminating inhibitors.
Proceedings of
the National
Academy
of Sciences of the United States of America 74, 12 (1977), 5463–7.
149
Bibliography
[71]
Schwende, I., and Pham, T. D. Pattern recognition and probabilistic
measures in alignment-free sequence analysis.
Briefings in Bioinformatics
15, 3 (2014), 354–368.
[72]
Sievers,
F.,
and Higgins,
D.
G.
Clustal
Omega.
Current Protocols
in Bioinformatics 2014 (2014), 3.13.1–3.13.16.
[73]
Slaney, M., and Casey, M. Lecture notes:
Locality-sensitive hashing
for finding nearest neighbors, 2008.
[74]
Smith, T. F., and Waterman, M. S. Identification of common molec-
ular subsequences.
Journal
of Molecular Biology 147, 1 (1981), 195–197.
[75]
Sood,
S.,
and Loguinov,
D.
Probabilistic Near-Duplicate Detection
Using Simhash.
Framework, 1 (2011), 1117–1126.
[76]
Strigl,
D.,
Kofler,
K.,
and Podlipnig,
S.
Performance and Scal-
ability of
GPU-Based Convolutional
Neural
Networks.
2010 18th Eu-
romicro Conference on Parallel, Distributed and Network-based Processing
(2010), 317–324.
[77]
Tan,
C.
C.,
and Eswaran,
C.
Reconstruction of
handwritten digit
images using autoencoder neural
networks.
In Canadian Conference on
Electrical
and Computer Engineering (2008), pp. 465–469.
[78]
Thompson, J. D., Gibson, T. J., Plewniak, F., Jeanmougin, F.,
and Higgins,
D.
G.
The CLUSTAL X windows interface:
Flexible
strategies for multiple sequence alignment aided by quality analysis tools.
Nucleic Acids Research 25, 24 (1997), 4876–4882.
[79]
Thompson,
J.
D.,
Higgins,
D.
G.,
and Gibson,
T.
J.
CLUSTAL
W:
improving the sensitivity of progressive multiple sequence alignment
through sequence weighting,
position-specific gap penalties and weight
matrix choice.
Nucleic acids research 22, 22 (1994), 4673–4680.
150
Bibliography
[80]
Thompson,
J.
D.,
Plewniak,
F.,
and Poch,
O.
A comprehensive
comparison of
multiple sequence alignment programs.
Nucleic acids re-
search 27, 13 (1999), 2682–2690.
[81]
Tromp, E., and Pechenizkiy, M. Graph-based N-gram language iden-
tification on short texts.
”Proceedings of
the 20th annual
Belgian-Dutch
Conference on Machine Learning” (2011), 27–34.
[82]
Tucker,
T.,
Marra,
M.,
and Friedman,
J. M.
Massively Parallel
Sequencing:
The Next Big Thing in Genetic Medicine, 2009.
[83]
Vincent, P., Larochelle, H., Lajoie, I., Bengio, Y., and Man-
zagol, P.-A.
Stacked Denoising Autoencoders:
Learning Useful Repre-
sentations in a Deep Network with a Local Denoising Criterion.
Journal
of Machine Learning Research 11, 3 (2010), 3371–3408.
[84]
Vinga, S., and Almeida, J.
Alignment-free sequence comparison - A
review.
Bioinformatics 19, 4 (2003), 513–523.
[85]
Vogels,
T.
P.,
Rajan,
K.,
and Abbott,
L.
F.
Neural
network
dynamics.
Annual
review of neuroscience 28 (2005), 357–76.
[86]
Wagner, R. a., and Fischer, M. J.
The String-to-String Correction
Problem.
Journal
of the ACM 21, 1 (1974), 168–173.
[87]
Wang, J., He, H., and Prokhorov, D. V.
A folded neural network
autoencoder for dimensionality reduction.
In Procedia Computer Science
(2012), vol. 13, pp. 120–127.
[88]
Wang,
W.,
Huang,
Y.,
Wang,
Y.,
and Wang,
L.
Generalized
autoencoder:
A neural
network framework for dimensionality reduction.
In IEEE Computer Society Conference on Computer Vision and Pattern
Recognition Workshops (2014), pp. 496–503.
151
Bibliography
[89]
Werbos, P. J. Beyond Regression:
New Tools for Prediction and Anal-
ysis in the Behavioral
Sciences.
PhD thesis, 1974.
[90]
Wilson, S. R.
Introduction to computational biology:
maps, sequences
and genomes.
Statistics in Medicine 15, 20 (1996), 2264.
[91]
Xiong,
H.
Y.,
Alipanahi,
B.,
Lee,
L.
J.,
Bretschneider,
H.,
Merico,
D.,
Yuen,
R.
K.
C.,
Hua,
Y.,
Gueroussov,
S.,
Na-
jafabadi,
H.
S.,
Hughes,
T.
R.,
Morris,
Q.,
Barash,
Y.,
Krainer,
A.
R.,
Jojic,
N.,
Scherer,
S.
W.,
Blencowe,
B.
J.,
and Frey, B. J.
The human splicing code reveals new insights into the
genetic determinants of disease.
Science 347, 6218 (2015), 1254806.
[92]
Zhang, Y. Q., and Rajapakse, J. C.
Machine Learning in Bioinfor-
matics.
2008.
152
